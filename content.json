{"meta":{"title":"素伯的博客","subtitle":"生死有命 富贵在天 —— 2018","description":"这是素伯（Super）的博客，随笔写写小教程，与记录学习心得或笔记，也倾述一些生活的无奈。写诗，写词，写人生。","author":"Super","url":"http://blog.mrsuper.top"},"pages":[],"posts":[{"title":"微信小程序，了解一下！","slug":"other/wx/applet","date":"2018-09-06T15:17:47.000Z","updated":"2018-09-06T09:29:47.204Z","comments":true,"path":"2018/09/06/other/wx/applet/","link":"","permalink":"http://blog.mrsuper.top/2018/09/06/other/wx/applet/","excerpt":"","text":"相关资料 官方文档 linux 上开发 工具安装 爱折腾才是程序猿的天性，在 linux 上开发小程序就是麻烦，在我机子上（Deepin 15.7）打开开发工具之后，快捷方式失灵，系统卡巴斯基。像中了“欲生欲死”病毒一样，各种诡异，欲哭无泪。最后总结：微信与游戏的开发还是选择 windows 系统吧，反正我是双系统，哈哈哈～","categories":[{"name":"Other","slug":"Other","permalink":"http://blog.mrsuper.top/categories/Other/"}],"tags":[{"name":"wx","slug":"wx","permalink":"http://blog.mrsuper.top/tags/wx/"},{"name":"applet","slug":"applet","permalink":"http://blog.mrsuper.top/tags/applet/"}]},{"title":"实际开发中“超实用工具/插件”","slug":"other/project/js-tools","date":"2018-09-06T14:29:23.000Z","updated":"2018-09-06T07:24:30.798Z","comments":true,"path":"2018/09/06/other/project/js-tools/","link":"","permalink":"http://blog.mrsuper.top/2018/09/06/other/project/js-tools/","excerpt":"","text":"在实际开发中，经常实现一些小功能 复制 Clipboard.js APP/H5 交互、唤起 魔窗 富文本 Quill.js WangEditor 百度 UEditor KindEditor 时间处理 Moment 图形图表 百度 Echarts Vue Echarts 加密 js MD5 文件上传 阿里云 OSS 直播 flv.js 拉流","categories":[{"name":"Other","slug":"Other","permalink":"http://blog.mrsuper.top/categories/Other/"}],"tags":[{"name":"tools","slug":"tools","permalink":"http://blog.mrsuper.top/tags/tools/"}]},{"title":"样式层叠表 CSS","slug":"css/preprocessor/css","date":"2018-09-02T14:29:23.000Z","updated":"2018-09-06T09:30:51.801Z","comments":true,"path":"2018/09/02/css/preprocessor/css/","link":"","permalink":"http://blog.mrsuper.top/2018/09/02/css/preprocessor/css/","excerpt":"","text":"层叠样式表（英文全称：Cascading Style Sheets）是一种用来表现 HTML（标准通用标记语言的一个应用）或 XML（标准通用标记语言的一个子集）等文件样式的计算机语言。CSS 不仅可以静态地修饰网页，还可以配合各种脚本语言动态地对网页各元素进行格式化。CSS 能够对网页中元素位置的排版进行像素级精确控制，支持几乎所有的字体字号样式，拥有对网页对象和模型样式编辑的能力。——百度百科 相关教程 菜鸟先飞 CSS CSS3 UI 框架 MUI Bootstrap v4","categories":[{"name":"CSS","slug":"CSS","permalink":"http://blog.mrsuper.top/categories/CSS/"}],"tags":[{"name":"css","slug":"css","permalink":"http://blog.mrsuper.top/tags/css/"}]},{"title":"极快的类 Next.js 的 React 应用框架。","slug":"js/react/umi-config","date":"2018-08-28T16:58:58.000Z","updated":"2018-09-06T09:30:51.802Z","comments":true,"path":"2018/08/29/js/react/umi-config/","link":"","permalink":"http://blog.mrsuper.top/2018/08/29/js/react/umi-config/","excerpt":"","text":"umi，中文可发音为乌米，是一个可插拔的企业级 react 应用框架。umi 以路由为基础的，支持类 next.js 的约定式路由，以及各种进阶的路由功能，并以此进行功能扩展，比如支持路由级的按需加载。然后配以完善的插件体系，覆盖从源码到构建产物的每个生命周期，支持各种功能扩展和业务需求，目前内外部加起来已有 50+ 的插件。umi 是蚂蚁金服的底层前端框架，已直接或间接地服务了 600+ 应用，包括 java、node、H5 无线、离线（Hybrid）应用、纯前端 assets 应用、CMS 应用等。他已经很好地服务了我们的内部用户，同时希望他也能服务好外部用户。 相关资料很久很久以前，他叫五米，后面就成了乌米！我就懒得改了，乳名才富有亲切感。 五米 - 官网 GitHub 不知不觉，五米 - 官网新增了中文版，果然效率 0. 安装与初始化基于 linux 系统开发，并使用 yarn 包管理工具 12345678910111213141516# 全局 umi 命令yarn global add umi# 新建项目主目录mkdir myumi &amp;&amp; cd myumi# 使用脚手架生成页面# 建议手动新建，将 `page/` 存放与 `src/` 目录下umi generate page index# 启动项目# 自动打开浏览器# 每次修改了配置文件，都会重新打开一个新页面，不适合开发umi dev# 建议带上参数 BROWSER=none，后面会写入配置文件# BROWSER=none umi dev 0.1 create-umi 脚手架Umi 2018-09-02 17:48:57 更新了脚手架，与 vue-cli v3 一样，可以界面式的自定义构建项目配置，nice！ 1234567mkdir myumi &amp;&amp; cd myumiyarm create umi# 一顿操作之后 ...# 启动即可yarn start 1. 约定式目录 dist/：默认打包目录 mock/：模拟 API 路径 src/：源码路径（可选，建议加上） src/page：路由目录（建议使用约定式路由） src/layouts：全局布局 config/config.js：umi 配置（不选用） .umirc.js：umi 配置（推荐使用） .env：环境变量配置 1.0 Umi 配置 umi webpack umi-plugin-react 1234567891011121314151617181920212223242526272829303132333435363738394041424344// .umirc.js 配置文件const path = require('path')function resolve (dir) &#123; return path.join(__dirname, dir)&#125;export default &#123; // 使用 hash 路径 // 不建议使用，除非有不可抗因素... // history: 'hash', plugins: [ // umi 插件配置 // 记得安装：yarn add umi-plugin-react // umi-plugin-react 是插件集，默认所有不开启 ['umi-plugin-react', &#123; // 使用 dva dva: &#123; immer: true, dynamicImport: true, hmr: true &#125;, // 使用 antd ui antd: true, // 配置所有页面的默认 title title: &#123; defaultTitle: 'web H5' &#125; &#125;] ], // 配置目录别名 `alias` chainWebpack (config, &#123; webpack &#125;) &#123; config.resolve.alias.set('$api', resolve('src/api')) config.resolve.alias.set('$components', resolve('src/components')) config.resolve.alias.set('$utils', resolve('src/utils')) &#125;, // 使用 sass // 记得安装：yarn add node-sass sass-loader sass: &#123;&#125;&#125; 1.1 环境变量配置12345# 每次启动或修改配置文件，不再打开浏览器新页面BROWSER=none# 指定端口PORT=8090 1.2 Mock API1234567891011121314151617181920212223242526// mock/rules.js 配置const Mock = require('mockjs')export default &#123; 'get /rules': (req, res) =&gt; &#123; // 模拟延迟 setTimeout(() =&gt; &#123; // 设置请求头 res.setHeader('Access-Control-Allow-Origin', '*') // 返回数据 res.json(&#123; result: Mock.mock(&#123; 'data|10': [&#123; name: '@cname', about: '@cparagraph', birthday: '@datetime', address: '@city(true)', avatar: '@image(100x100, @color)', 'gender|0-2': 0 &#125;] &#125;) &#125;) &#125;, 1600) &#125;&#125; 1.3 约定式路由 src/pages/404.js：404 页面，开发环境中，不会触发，但是可以输入 /404 访问！ src/pages/document.ejs：HTML 模板 src/pages/user/$id.js：动态路由，id 为 match.params.id 参数 src/pages/user/modules/user.js：dva 的配置，不需要指定 namespace，默认为文件名 user src/pages/user/module.js：dva 的配置，当 module 为单个时，建议使用这种方式，但需要指明 namespace: &#39;user&#39; src/pages/course/$id$.js：动态并且可选路由，id 为 match.params.id 参数，可能为 null src/pages/list/_layout.js：嵌套路由，list/ 目录下面所有页面都基于 _layout.js","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://blog.mrsuper.top/categories/JavaScript/"},{"name":"React","slug":"JavaScript/React","permalink":"http://blog.mrsuper.top/categories/JavaScript/React/"}],"tags":[{"name":"react","slug":"react","permalink":"http://blog.mrsuper.top/tags/react/"},{"name":"umi","slug":"umi","permalink":"http://blog.mrsuper.top/tags/umi/"}]},{"title":"一键打包，一键部署？ Shell 脚本语言","slug":"linux/toots/shell","date":"2018-08-18T21:57:09.000Z","updated":"2018-09-03T08:39:08.062Z","comments":true,"path":"2018/08/19/linux/toots/shell/","link":"","permalink":"http://blog.mrsuper.top/2018/08/19/linux/toots/shell/","excerpt":"","text":"使用命令行的真谛在于便捷、快速、高效（其实就是为了装 ×）。但是当要完成一个操作需要几十个命令，并且时不时需要执行一次，那么头就大了，我猜你已经想到了。我们可以把所有命令保存在 word 文档，需要的时候再复制过来执行，那么问题来了，如果再来一个操作任务，很多命令都是跟前者相同的，我们是不是还得再复制一个 word 档，只修改其中几个命令参数？别傻了，肯定是选择强大的脚本语言 Shell！ 相关教程 菜鸟快跑 基础12345678910111213141516171819202122232425262728293031323334353637383940# 当行注释:&lt;&lt;! 推荐使用这种方式来注释多行内容。 这里是多行注释～ 使用“感叹号”收尾！!# 变量# 以字母、下划线开头的一次标识码，如：# 等号两边不能存在空格# 使用分号分割语句，或换行（推荐）_private_var=77577CONST_VAR='ENTER_KEY'yourName='Super'age=18# 声明只读常量，不允许修改readonly CONST_VAR# 使用变量与常量，前面带上 $ 符号echo $ageecho $yourName# 删除变量unset _private_var# 字符串# 单引号会直接打印出内容，里面不能包含单引号single='这是使用单引号包住'# 1. 双引号里可以有变量# 2. 双引号里可以出现转义字符doublekill=\"这是使用\\\"双引号\\\"包住，可以输出变量 $age=$&#123;age&#125;\"# 长度$&#123;#single&#125;# 子串$&#123;doublekill:4:8&#125;# 查找字符下标位置echo 'expr index \"$single\" io'# 数组 真实用例贴一个我打包个人博客的 Shell 脚本 1234567891011121314151617181920212223242526272829#!/bin/bash# 切换至本地主分支git checkout master# 发布 coding 版本git checkout coding-pagegit merge master -m \"[MERGE] 合并 master 分支\"hexo generatecp robots.txt public/robots.txt# 这里 * 号指百度收录的 keyecho ******** &gt; public/baidu_verify_1EuuCBkjB4.htmlecho blog.mrsuper.top &gt; public/CNAMEhexo deplo# 发布 github 版本git checkout github-pagegit merge master -m \"[MERGE] 合并 master 分支\"hexo generatecp robots.txt public/robots.txtecho gh.mrsuper.top &gt; public/CNAMEhexo deplogit# 切回主分支git checkout master","categories":[{"name":"Linux","slug":"Linux","permalink":"http://blog.mrsuper.top/categories/Linux/"},{"name":"Tools","slug":"Linux/Tools","permalink":"http://blog.mrsuper.top/categories/Linux/Tools/"}],"tags":[{"name":"tools","slug":"tools","permalink":"http://blog.mrsuper.top/tags/tools/"},{"name":"shell","slug":"shell","permalink":"http://blog.mrsuper.top/tags/shell/"}]},{"title":"迅易通（闻商）","slug":"live/work/xunyitong","date":"2018-08-14T22:14:24.000Z","updated":"2018-09-03T08:39:08.063Z","comments":true,"path":"2018/08/15/live/work/xunyitong/","link":"","permalink":"http://blog.mrsuper.top/2018/08/15/live/work/xunyitong/","excerpt":"","text":"毕业后的第一份工作（2014年5月12日），广州迅易通（广州闻商科贸有限公司），唯一一家能让我感觉像大家庭的企业。那里有好多可爱、天真无邪的同事，还有超暖、超体贴的 Boss（Tonny），我离职还硬性要送 ￥999 机械建盘给我，感动也挺尴尬！那二十多个月里是我没能抓住机会，没有那种职场绝地反击之力，也只能怪自己当时年少不成熟，没有远见，没有找到一条适合自己的路去深入探索。我觉得那里是我的青春，懵懂无知，无忧无虑，虽然拿着还达不到扣个税的薪水。但总好过现在这么痛苦，有时候想得多，痛苦也就跟着多！ 那时候时不时搞一次全公司大规模户外旅游或拓展，第一次是《大夫山森林公园-烧烤》。烧完烤还有悠闲的玩《天黑请闭眼》，后来才知道那个游戏叫《狼人杀》，哈哈哈哈～第一次与他们这么多互动与交流，很庆幸大家大都是刚毕业的，有些还是实习生，最老的也只是毕业快一年的老同事！聊的当然是大学在哪里读，读什么专业，为什么当时要选苦逼的“软件开发”专业？为什么进这家公司？等等，都是些天真的小疑问！ 第二次是《深圳东西涌-暴走》，实在累啊，全程二十多公里，还有各种奇奇怪怪的山路。海边风景虽然美，但这一身疲惫的身躯，哪里有精力去欣赏，真正的有心无力，哈哈哈～从西涌到东涌，走了四个小时多，中途休息了一次，最后到达目的地，脱了鞋，在海边泡脚、看看比基尼（就两三个妹子），应该是那一整天里最确幸的时刻吧！最后回到广州，果然整个人黑了两圈！ 第三次是《汉溪长隆游乐园》，刺激的都玩过了！ 第四次是《从化摘桔子》，没有太多精彩的内容，一路上边聊边摘边吃！ “有生之年”的最后一次团建是《番禺新造-户外素质拓展》，真正体验了一次团队合作的活动，全公司分成四个组，我也有幸地成为“超勇队”队长，每个队长还分配了一个女助教，哈哈哈～每次比拼完，教官都会给十几分钟给团队内部分享，那时候我说了：“我没有领导指挥的经验，也没有这种潜力跟智慧，我会尽力，大家也尽力就行了！”。那时前几次比拼我们不是第三，就是最后一名，其中有一组已经浮出冠军相，他们的分数已经远远的超越了我们其他三组。但是，什么叫绝地反击？最后的两次比拼里我们队都是率先完成任务，而冠军相的那组时间结束后还没完成任务，最后我们组反败为胜，实现绝地反击胜利！真的好刺激，好激动人心！","categories":[{"name":"Live","slug":"Live","permalink":"http://blog.mrsuper.top/categories/Live/"},{"name":"Work","slug":"Live/Work","permalink":"http://blog.mrsuper.top/categories/Live/Work/"}],"tags":[{"name":"work","slug":"work","permalink":"http://blog.mrsuper.top/tags/work/"}]},{"title":"最强 Subversion 命令行","slug":"linux/toots/svn","date":"2018-08-07T18:05:52.000Z","updated":"2018-09-03T08:39:08.062Z","comments":true,"path":"2018/08/08/linux/toots/svn/","link":"","permalink":"http://blog.mrsuper.top/2018/08/08/linux/toots/svn/","excerpt":"","text":"看到 Subversion 这个单词是不是很陌生？其实她就是我们最熟悉不过的 svn 了。svn 是中心集中机制的理念，所以我都称 svn 的中心版本库为“总部”，是不是很形象！在 linux 中使用 svn 果断使用命令行方式，怎么快怎么来，怎么方便怎么来！ 相关教程 Subversion 版本控制 1. 安装123456789# Ubutun 下使用 apt-getsudo apt-get install subversion# 检测svn --version# 帮助文档svn ?# 同等于：svn help 2. 拉取总部版本库1234svn checkout svn://url...# 类似于 Gitgit clone git@url... 3. 从总部更新版本内容123456svn update# 会打印出当前最新 svn 提交的版本号# 类似于git fetchgit pull 4. 修改内容后，提交内容12345678910111213141516171819# 查看修改情况# 很慢，仓库更大时更明显svn status# 如果没有任何内容变化，命令窗口真的什么都不打印出来# 有点意思！# 把内容添加到缓冲区svn add [filename]# 提交内容到总部svn commit# 携带信息（svn 不强制注释，不够优秀啊）# svn commit -m [message]# 类似于git statusgit add [filename]git commit -m [message]git push origin master 5. 丢弃已编辑的内容（谨慎！）1234svn revert [filename]# 类似于git checkout -- [filename]","categories":[{"name":"Linux","slug":"Linux","permalink":"http://blog.mrsuper.top/categories/Linux/"},{"name":"Tools","slug":"Linux/Tools","permalink":"http://blog.mrsuper.top/categories/Linux/Tools/"}],"tags":[{"name":"tools","slug":"tools","permalink":"http://blog.mrsuper.top/tags/tools/"},{"name":"svn","slug":"svn","permalink":"http://blog.mrsuper.top/tags/svn/"}]},{"title":"Web 开发，前后端分离之“跨域”问题","slug":"server/cross-domain","date":"2018-08-06T21:23:40.000Z","updated":"2018-09-03T08:39:08.063Z","comments":true,"path":"2018/08/07/server/cross-domain/","link":"","permalink":"http://blog.mrsuper.top/2018/08/07/server/cross-domain/","excerpt":"","text":"WEB 开发，前后端分离基本成互联网技术团队的标配！有点很明显，后端只需关心业务逻辑与数据的存取，前端负责整站的路由控制与页面数据展示、用户交互体验。但也有缺点，而且还不少，第一个就是跨域问题更迫切了！ 相关资料 Express，基于 Node.js 平台的 WEB 开发框架 概念跨域！顾名思义，跨越不同域名下的服务器请求资源。 前端发起请求，什么请求头都携带，或者无自定义请求头 后端检测是否在允许的域名访问内，如果在则返回数据 或 前端发起请求，又携带了自定义的请求头 服务器会先返回 Option 方法的访问结果 检测请求头是否在允许访问内，如有则返回数据 1. 后端服务器设置切记！是后端服务器，而不是后端代码。 Express 的 /app.js12345678910111213141516171819202122232425262728293031323334353637383940414243var express = require('express')var path = require('path')var cookieParser = require('cookie-parser')var logger = require('morgan')var app = express()app.use(logger('dev'))app.use(express.json())app.use(express.urlencoded(&#123; extended: false &#125;))app.use(cookieParser())/* * 使用静态文件 * 直接访问 */app.use(express.static(path.join(__dirname, 'public')))// 放在所有请求的上面// 处理跨域问题app.all('*', (req, res, next) =&gt; &#123; // 设置支持跨域的域名，便于开发使用或使用代理 const origins = ['http://localhost:3000', 'http://localhost:3001', 'http://wx.mrsuper.top'] if(origins.includes(req.headers.origin)) &#123; // 设置允许使用所有权限 res.header('Access-Control-Allow-Origin', '*') res.header('Access-Control-Allow-Credentials', true) // 允许携带以下请求头属性 // Origin 为代理时使用 // Authorization 为自定义 res.header('Access-Control-Allow-Headers', 'Origin, X-Requested-With, Content-Type, Accept, Authorization') // 允许访问的方法 res.header('Access-Control-Allow-Methods', 'OPTIONS, POST, DELETE, PUT, GET') &#125; next()&#125;)app.use('/', require('./routes/index'))module.exports = app 2. 前端远程请求将一些繁琐而必要的配置项配置到请求公共方法里 2.1 fetch 配置12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import Qs from 'qs'let HOST = 'http://mrsuper.top:8000/'if (process.env.NODE_ENV === 'development') &#123; HOST = 'http://localhost:3000/'&#125;function parseJSON (response) &#123; return response.json()&#125;function checkStatus (response) &#123; if (response.status &gt;= 200 &amp;&amp; response.status &lt; 300) &#123; return response &#125; const error = new Error(response.statusText) error.response = response throw error&#125;export default function http (url, options) &#123; if (options &amp;&amp; options.body) &#123; /* 二选一即可 */ // 配合 application/x-www-form-urlencoded options.body = Qs.stringify(options.body) // 配合 application/json // 使用 JSON 的序列化即可 // options.body = JSON.stringify(options.body) &#125; return fetch(HOST + url, &#123; ...options, headers: &#123; // 自定义请求头 'Content-Type': 'application/x-www-form-urlencoded', // 'Content-Type': 'application/json', // 自定义请求头 // 切记，一定需要后端配置允许，不然也访问不了 Authorization: window.localStorage.getItem('token') &#125; &#125;) .then(checkStatus) .then(parseJSON) .then(data =&gt; &#123; return data &#125;) .catch(err =&gt; &#123; return err &#125;)&#125; 2.2 使用基于 fetch 的 Axios1234567891011121314151617181920212223242526272829303132import axios from 'axios'import Qs from 'qs'// 生成调用地址let HOST = 'http://mrsuper.top:8000/'if (process.env.NODE_ENV === 'development') &#123; // 开发调用地址 HOST = 'http://localhost:3000/'&#125;const Axios = axios.create(&#123; baseURL: HOST, timeout: 4000, // 使用 Node 内置的 qs 模块，把数据进行序列化 transformRequest: [data =&gt; Qs.stringify(data)]&#125;)Axios.interceptors.request.use(function (config) &#123; // 设置请求头 config.headers = &#123; // 使用 application/x-www-form-urlencode，需要 Qs.stringify 的配合 'Content-Type': 'application/x-www-form-urlencoded', // 自定义请求头 // 切记，一定需要后端配置允许，不然也访问不了 Authorization: window.localStorage.getItem('token') &#125; return config&#125;, function (error) &#123; return Promise.reject(error)&#125;)export default Axios","categories":[{"name":"Server","slug":"Server","permalink":"http://blog.mrsuper.top/categories/Server/"}],"tags":[{"name":"server","slug":"server","permalink":"http://blog.mrsuper.top/tags/server/"},{"name":"cross domain","slug":"cross-domain","permalink":"http://blog.mrsuper.top/tags/cross-domain/"}]},{"title":"Node.js 的 Web 框架之 Express.js","slug":"js/node/express","date":"2018-08-05T14:37:33.000Z","updated":"2018-09-06T07:24:30.797Z","comments":true,"path":"2018/08/05/js/node/express/","link":"","permalink":"http://blog.mrsuper.top/2018/08/05/js/node/express/","excerpt":"","text":"Node.js 是前端开发工程师的福音，会 JavaScript 那么就基本学会了 Node.js 一半多，而剩下的则是些服务器概念、机器底层的 API 接口、还有对数据库的增删改查。可以玩这么多玩意儿，难怪前端火得一塌糊涂！ 相关资料 Express，基于 Node.js 平台的 WEB 开发框架 密码加密 crypto 登录 Token HandleBars 模板引擎 跨域处理 服务器配置Express 的服务器配置文件就是根目录的 /app.js，修改里面的内容，添加自己需要的配置即可。 1. 路由配置1234567// app.use([path] [, route] [, callback])// path: 前端访问的路径// route: 基于 express 的 router// callback 访问回调app.use('/', require('./routes/index'))app.use('/login', require('./routes/login'))app.use('/register', require('./routes/register')) /routes/index.js12345678const express = require('express')const router = express.Router()router.get('/', function(req, res, next) &#123; res.render('index', &#123; title: 'Express' &#125;)&#125;)module.exports = router 2. 404 配置1234567891011121314151617// 404// 没有路由配置，只有回调参数// 放置所有请求路由的后面app.use((req, res, next) =&gt; &#123; // 使用 json 返回报错 res.json(&#123; code: '404', message: '找不到对象！' &#125;) /* // 使用报错机制对前端不友好 res.status(404).send(&#123; message: 'Sorry cant find that!' &#125;) */&#125;) 3. 500 配置1234567891011121314151617// 500// 错误处理，必须显性带上 4 个参数app.use((err, req, res, next) =&gt; &#123; // 使用 json 返回报错 res.json(&#123; code: '500', message: '服务器错误！', error: err &#125;) /* // 使用报错机制对前端不友好 res.status(500).send(&#123; message: err || 'Something broke!' &#125;) */&#125; 4. 开发跨域设置123456789101112131415/* * 处理跨域问题 */app.all('*', (req, res, next) =&gt; &#123; // 支持跨域的域名 const origins = ['http://localhost:3000', 'http://localhost:3001', 'http://wx.mrsuper.top'] if(origins.includes(req.headers.origin)) &#123; res.header('Access-Control-Allow-Origin', '*') res.header('Access-Control-Allow-Credentials', true) // 允许携带以下请求头属性 res.header('Access-Control-Allow-Headers', 'Origin, X-Requested-With, Content-Type, Accept, Authorization') res.header('Access-Control-Allow-Methods', 'OPTIONS, POST, DELETE, PUT, GET') &#125; next()&#125;) 5. 注册密码加密123456// regsiter.jsconst crypto = require('crypto')const password = crypto.createHash('md5').update(password).digest('hex')// 这样就可以把 password 存入数据库 6. 登录生成 token123456789// login.js// 选择先 npm install --save jsonwebtokenconst jwt = require('jsonwebtoken')const token = jwt.sign(&#123; id: userID,&#125;, 'express-mysql')// 这样就可以把 token 返回给前端 7. 配置模板引擎12345678const exphbs = require('express-handlebars')/** * 模板引擎：Handlebars */app.engine('handlebars', exphbs(&#123; defaultLayout: 'main' &#125;))app.set('view engine', 'handlebars')app.set('views', './views') 完整的 Express /app.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129var express = require('express')var path = require('path')var cookieParser = require('cookie-parser')var logger = require('morgan')const jwt = require('jsonwebtoken')const exphbs = require('express-handlebars')var app = express()/** * 模板引擎：Handlebars */app.engine('handlebars', exphbs(&#123; defaultLayout: 'main' &#125;))app.set('view engine', 'handlebars')app.set('views', './views')app.use(logger('dev'))app.use(express.json())app.use(express.urlencoded(&#123; extended: false &#125;))app.use(cookieParser())/* * 使用静态文件 * 直接访问 */app.use(express.static(path.join(__dirname, 'public')))/* * 处理跨域问题 */app.all('*', (req, res, next) =&gt; &#123; // 支持跨域的域名 const origins = ['http://localhost:3000', 'http://localhost:3001', 'http://wx.mrsuper.top'] if(origins.includes(req.headers.origin)) &#123; res.header('Access-Control-Allow-Origin', '*') res.header('Access-Control-Allow-Credentials', true) // 允许携带以下请求头属性 res.header('Access-Control-Allow-Headers', 'Origin, X-Requested-With, Content-Type, Accept, Authorization') res.header('Access-Control-Allow-Methods', 'OPTIONS, POST, DELETE, PUT, GET') &#125; // 不需要 token 的请求 const notTokens = ['/login', '/register'] const path = req.params[0] const token = req.headers.authorization if (!notTokens.includes(path)) &#123; // 判断是否带有 token if (!token) &#123; return res.json(&#123; code: 100, message: '冇有 Token！' &#125;) &#125; // 验证 token var account = jwt.verify(token, 'express-mysql') if (!account.id) &#123; return res.json(&#123; code: 119, message: 'Token 有问题，请重新登录！' &#125;) &#125; // 验证是否过期（7 天） if (Date.now() - account.iat * 1000 &gt; 7 * 24 * 60 * 60 * 1000) &#123; return res.json(&#123; code: 120, message: 'Token 已过期，请重新登录！' &#125;) &#125; &#125; next()&#125;)app.use('/', require('./routes/index'))app.use('/login', require('./routes/login'))app.use('/register', require('./routes/register'))// 读取表数据app.use('/table', require('./routes/table'))app.use('/account', require('./routes/account'))// mock 模拟app.use('/mock', require('./routes/table/users'))// 模板引擎页面app.use('/home', require('./routes/modules/home'))/* * 404 */app.use((req, res, next) =&gt; &#123; // 使用 json 返回报错 res.json(&#123; code: '404', message: '找不到对象！' &#125;) /* res.status(404).send(&#123; message: 'Sorry cant find that!' &#125;) */&#125;)/* * 500 * 错误处理，必须显性带上 4 个参数 */app.use((err, req, res, next) =&gt; &#123; if (err.name === 'JsonWebTokenError') &#123; return res.json(&#123; code: '110', message: 'token 有问题，请重新登录！' &#125;) &#125; // 使用 json 返回报错 res.json(&#123; code: '500', message: '服务器错误！', error: err &#125;) /* res.status(500).send(&#123; message: err || 'Something broke!' &#125;) */&#125;)module.exports = app","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://blog.mrsuper.top/categories/JavaScript/"},{"name":"Node","slug":"JavaScript/Node","permalink":"http://blog.mrsuper.top/categories/JavaScript/Node/"}],"tags":[{"name":"node","slug":"node","permalink":"http://blog.mrsuper.top/tags/node/"},{"name":"express","slug":"express","permalink":"http://blog.mrsuper.top/tags/express/"}]},{"title":"Linux 常用命令","slug":"linux/system/command","date":"2018-08-01T21:44:49.000Z","updated":"2018-08-03T02:05:36.712Z","comments":true,"path":"2018/08/02/linux/system/command/","link":"","permalink":"http://blog.mrsuper.top/2018/08/02/linux/system/command/","excerpt":"","text":"这里记录了 Me 接触 Linux 以来经常用到、但又死活记不住的命令。也记录了一些不常用，但又超实用的命令。Shell 脚本可以最大化减少工作量，提高效率。还有各种小技巧供大家参考参考，希望大家喜欢。 内核、硬件信息1、查看运行程序对 CPU、内存、等使用情况，以列表形式展示。 1top 运行之后可按以下键值排序 P（按 CPU 使用情况排序） M（按内存使用情况排序） T（按 MITE+ 排序） 2、查看内存使用情况 1ps 3、查看文件占用大小 1du -sh * 文本1、查看文本内容，把内容都打印至窗口，很简单，喵一下！ 12345678910111213141516171819202122232425cat ~/miao.txt# 反过来打印# cat 反过来写，很形象！tac ~/miao.txt# 可以翻页# 往下：ctrl-f# 往上：ctrl-b# 使用回车往下滚动一行more ~/miao.txt# 使用 vim 预览模式的功能# 可以使用 k/j，上下滚动# gg: 第一行# G：最后一行less ~/miao.txt# 打印前几行内容# 默认前 10 行head ~/miao.txt -n 20# 打印后几行内容# 默认后 10 行tail ~/miao.txt -n 20","categories":[{"name":"Linux","slug":"Linux","permalink":"http://blog.mrsuper.top/categories/Linux/"},{"name":"System","slug":"Linux/System","permalink":"http://blog.mrsuper.top/categories/Linux/System/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://blog.mrsuper.top/tags/linux/"},{"name":"command","slug":"command","permalink":"http://blog.mrsuper.top/tags/command/"}]},{"title":"基于 Linux 搭建 Web 前端开发环境","slug":"linux/system/web-develop","date":"2018-07-29T12:54:11.000Z","updated":"2018-09-03T08:39:08.061Z","comments":true,"path":"2018/07/29/linux/system/web-develop/","link":"","permalink":"http://blog.mrsuper.top/2018/07/29/linux/system/web-develop/","excerpt":"","text":"菩萨畏因，众生畏果。web 前端开发发展速度迅猛，构建工具、开发辅助程序、一键命令启动，五花八门，那么想在 Linux 上面能搭建敏捷开发环境，得下一般功夫才行。所以我在这里给大家记录那些踩过的坑，也方便以后翻查。 1. 编辑器 VimLinux 系统大都自带 vim 编辑器，所以只需配置符合自己开发习惯跟工作开发需要的插件即可，请看这篇《编辑器之神 Gvim》。 2. Node.js 环境12345sudo apt install node# 检测、可能版本太旧或全局命令不能用，请看“疑难杂症”node -vnpm -v 3. 版本控制工具 Git12345678# 简单方便，不需要别的配置sudo apt install git# 检测git --version# 可能默认的编辑器不是 vim，可能修改全局配置git config --global core.editor vim 4. 依赖管理 Yarn1234sudo apt install yarn# 检测、版本可能太旧，请看“疑难杂症”yarn --version 疑难杂症 Node 版本控制，使用 nvm 1234567891011121314151617181920# 下载，执行curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.1/install.sh | bash# 帮助信息nvm# 列出 node 所有版本nvm ls-remote# 安装某一版本nvm install v8.4.0# 使用已下载好的版本nvm use v8.4.0# 检测、全局有效node -v# 每次退出命令行，node 都会自动切回旧版本# 往后看，你就懂了！ Yarn 版本太旧 1234567891011# 卸载 cmdtest、yarnsudo apt remove cmdtestsudo apt remove yarn # 根据 URL 下载curl -sS https://dl.yarnpkg.com/debian/pubkey.gpg | sudo apt-key add -sudo tee /etc/apt/sources.list.d/yarn.list # 重新更新工具包、安装sudo apt updatesudo apt install yarn Yarn 或者 Npm 安装全局插件但不可用，需要配置环境变量 12345678910111213141516171819202122232425# 查看 yarn 全局安装目录yarn global bin# 打印出：/home/super/.yarn/bin# 查看 npm 全局安装目录npm -g bin# 打印出：/home/super/.nvm/versions/node/v10.7.0/bin# 将上面打印出来的目录，录入环境变量# “:”：冒号表示连接符，与 windows 中的“;”一样export PATH=$PATH:/home/super/.yarn/binexport PATH=$PATH:/home/super/.nvm/versions/node/v10.7.0/bin# 检测yarn global add hexo-clihexo --version# 每次退出命令行，变量环境都会失效# 将命令写入配置文件，一劳永逸（2 种方法，2 选 1）# vim /etc/profilevim ~/.bashrc# 将上面 export PATH=$PATH:/home/super/.yarn/bin 命令录入到文件最后一行# 执行下面命令马上生效# source /etc/profilesource ~/.bashrc windows 旧项目（Node 环境启动不了） 12# node-sass 报错，又安装不了npm rebuild node-sass","categories":[{"name":"Linux","slug":"Linux","permalink":"http://blog.mrsuper.top/categories/Linux/"},{"name":"System","slug":"Linux/System","permalink":"http://blog.mrsuper.top/categories/Linux/System/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://blog.mrsuper.top/tags/linux/"},{"name":"system","slug":"system","permalink":"http://blog.mrsuper.top/tags/system/"}]},{"title":"MySql 之旅","slug":"linux/database/mysql","date":"2018-07-28T12:24:09.000Z","updated":"2018-09-03T08:39:08.061Z","comments":true,"path":"2018/07/28/linux/database/mysql/","link":"","permalink":"http://blog.mrsuper.top/2018/07/28/linux/database/mysql/","excerpt":"","text":"大学学的 SQL Server 2005 已经忘得差不多了，很惭愧。不过现在有动力学习 SQL，只因工作所逼，昏君不作为，小的要造反。基于 Docker 搭建 MySql，使用 Node.js 进行连接、实现增删改查，崛起吧，小的们！ 相关资料 超有爱的中文官网 相关教程 菜鸟先飞 Docker 你值得拥有 1. 搭建环境123456789101112131415161718192021# 步骤1：新建存放数据、配置的目录mkdir -p ~/mysql/data ~/mysql/logs ~/mysql/conf# 步骤2：下载最新版本docker pull mysql# 步骤3：运行 mysql 容器# -p 端口映射# --rm 停止运行时删除容器（前期开发、试错、调试最好用）# --name 取名字# -v 目录映射# -e 全局参数cd ~/mysqldocker run -p 3306:3306 --rm --name supermysql -v $PWD/conf:/etc/mysql/conf.d -v $PWD/logs:/logs -v $PWD/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=666666 -d mysql# 添加用户# --------# 疑难杂症# 1.与本地 mysql（lnmp） 冲突# 停掉 mysql 服务 2. 连接123456# 使用 node-study 账户连接数据库mysql -u root -p# 回车后输入密码即可# 登录后并且切换到指定数据库mysql -d node-study -u root -p 3. 查看123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475-- 显示当前用户有权限操作的数据库-- 请注意需要加上分号表示语句结束SHOW DATABASES;-- 查看数据库下的所有表USE node-study;SHOW TABLES;-- 查看表的字段信息SHOW COLUMNS FROM users;-- 查看表内所有数据SELECT * FROM users;-- 查看某几列的数据SELECT id, name, log FROM users;-- 带查询条件查看数据-- 列数据范围-- =：等于-- &lt;&gt;：不等于-- !=：不等于-- &gt;：大于-- &lt;：小与-- &gt;=：大于等于-- &lt;=：小于等于SELECT * FROM users WHERE log &gt;= 18 AND log &lt;= 24;-- LIKE：包含，配合 % 符号，类似于正则的 * 号SELECT * FROM users WHERE name LIKE '%Chao';-- =/!=：对 NULL 值不起效-- IS NULL：是否为 NULL 值-- IS NOT NULL：是否不为 NULL 值-- &lt;=&gt;：判断符-- 查看数据并分页（第2页的10条数据）SELECT * FROM users LIMIT 10 OFFSET 10;-- 多表查询-- UNION：重复的内容会过滤掉-- UNION ALL：所有表所有数据都显示出来-- 注意：必须相同个数列SELECT name FROM usersUNIONSELECT name FROM blog;-- 数据排序-- ORDER BY：配合 ASC（升序/默认）、DESC（降序）SELECT name FROM usersUNIONSELECT name FROM blogORDER BY name DESC;-- 数据分组-- 可以使用方法，进行分组计算-- COUNT：总和-- AVG：平均数-- SUM：累加SELECT name, COUNT(*) FROM users GROUP BY name;-- WITH ROLLUP：计算相同的数据-- coalesce(a,b,c)：如果 a == null，则选择 b；如果 b == null，则选择 c；-- 如果 a != null，则选择 a；如果 a b c 都为 null ，则返回为 nullSELECT coalesce(name, '总数'), COUNT(*) FROM users GROUP BY name WITH ROLLUP;-- 数据连接-- INNER JOIN：内连接，等同于 WHERE 与 = 语句-- LEFT JOIN：左联接，不管匹不匹配，左边的表数据都会显示-- RIGHT JOIN：右连接，SELECT a.name, b.skill from users a INNER JOIN blog b ON a.name = b.name;SELECT a.name, b.skill from users a LEFT JOIN blog b ON a.name = b.name;SELECT a.name, b.skill from users a RIGHT JOIN blog b ON a.name = b.name;-- 正则，全球统一格式-- REGEXPSELECT * FROM users WHERE name REGEXP '^Sup'SELECT * FROM users WHERE name REGEXP 'hao$' 4. 创建1234567891011-- 创建数据库CREATE DATABASE node;-- 创建数据表CREATE TABLE users ( id INT NOT NULL AUTO_INCREMENT COMMENT '用户 ID', name VARCHAR(6) NOT NULL COMMENT '用户名', information TEXT NOT NULL COMMENT '个人简介', log DATE COMMENT '注册时间', PRIMARY KEY ( id )) ENGINE=InnoDB DEFAULT CHARSET=utf8; 5. 插入数据1INSERT INTO users ( name, information ) VALUES ( 'Super', 'Super is a man.' ); 6. 更新数据12-- 注意带上 WHERE 子句UPDATE users set name='Root', information='Root is a admin.' WHERE id=1; 7. 删除12345678-- 删除数据库DROP DATABASE node;-- 删除数据表DROP TABLE users;-- 删除表数据DELETE FROM users WHERE id=2; 8. 修改表12345678910111213-- 修改表名ALTER TABLE old_name RENAME TO new_name;-- 添加一个列字段ALTER TABLE `account` ADD `bgc` CHAR(7) NOT NULL DEFAULT '#00aabb' COMMENT '用户主页背景颜色' AFTER `regdate`;-- 删除一个列字段ALTER TABLE `account` DROP name;-- 修改一个列字段ALTER TABLE `account` MODIFY name VARCHAR(1000);-- 改变一个类字段，包括名字ALTER TABLE `account` CHANGE nianling age BIGINT; 9. 事务 原子性：一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。 一致性：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。 隔离性：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。 持久性：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。 123456789101112131415161718-- 开始事务-- START TRANSACTION;BEGIN;-- 回滚事务-- ROLLBACK WORK;ROLLBACK;-- 提交事务-- COMMIT WORK;COMMIT;-- 新建一个保存点SAVEPOINT id;-- 删除一个保存点RELEASE SAVEPOINT id;-- 回滚到一个保存点ROLLBACK TO id; 10. 索引1-- 未完待续 11. 临时表1-- 未完待续","categories":[{"name":"Linux","slug":"Linux","permalink":"http://blog.mrsuper.top/categories/Linux/"},{"name":"Database","slug":"Linux/Database","permalink":"http://blog.mrsuper.top/categories/Linux/Database/"}],"tags":[{"name":"database","slug":"database","permalink":"http://blog.mrsuper.top/tags/database/"},{"name":"mysql","slug":"mysql","permalink":"http://blog.mrsuper.top/tags/mysql/"}]},{"title":"Linux - Deepin 深度操作系统","slug":"linux/system/deepin","date":"2018-07-27T21:54:43.000Z","updated":"2018-09-06T07:24:30.756Z","comments":true,"path":"2018/07/28/linux/system/deepin/","link":"","permalink":"http://blog.mrsuper.top/2018/07/28/linux/system/deepin/","excerpt":"","text":"我觉得，想要成为一个优秀的程序员（码农），学习 Linux 是必经之路。由于作者博爱开源，Linux 发行版百家争鸣，分门别派。比较火的，即与同事们闲聊中都能听到的 RedHat、Centos、Ubuntu 等等，数不胜数。经过同事介绍，Deepin 系统是颜值派，基于 Ubuntu，那么还等什么，Here we go。 百度百科 Linux 是一套免费使用和自由传播的类 Unix 操作系统，是一个基于 POSIX 和 UNIX 的多用户、多任务、支持多线程和多 CPU 的操作系统。它能运行主要的 UNIX 工具软件、应用程序和网络协议。它支持 32 位和 64 位硬件。Linux 继承了 Unix 以网络为核心的设计思想，是一个性能稳定的多用户网络操作系统。 Linux 操作系统诞生于 1991 年 10 月 5 日（这是第一次正式向外公布时间）。Linux 存在着许多不同的 Linux 版本，但它们都使用了 Linux 内核。Linux 可安装在各种计算机硬件设备中，比如手机、平板电脑、路由器、视频游戏控制台、台式计算机、大型机和超级计算机。 严格来讲，Linux 这个词本身只表示 Linux 内核，但实际上人们已经习惯了用 Linux 来形容整个基于 Linux 内核，并且使用 GNU 工程各种工具和数据库的操作系统。 相关资料 鸟哥的 Linux 私房菜（密码：axzy） 相关教程 启动盘制作 下载镜像 Deepin 系统安装 疑难杂症 因为双系统，windows 下的 Git 项目在 Linux 下，所有文件添加了 ^M 换行符号 123# 在项目根目录下执行git checkout -- .# 也即是清除掉编辑过的内容 Ubuntu 系列发行版使用 apt、apt-get工具进行程序安装 12# 安装 nodeapt-get install node 开发时，很多命令需要权限（sudo），还要用户密码进行二次确认 12# 在命令前面加上 sudo 即可sudo apt install node 很意外 Ubuntu 中 Git 默认调用编辑器是 GUN nano使用 ctrl-o 保存，ctrl-x 退出 12# 修改 Git 全局编辑器git config --global core.editor vim","categories":[{"name":"Linux","slug":"Linux","permalink":"http://blog.mrsuper.top/categories/Linux/"},{"name":"System","slug":"Linux/System","permalink":"http://blog.mrsuper.top/categories/Linux/System/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://blog.mrsuper.top/tags/linux/"},{"name":"system","slug":"system","permalink":"http://blog.mrsuper.top/tags/system/"}]},{"title":"Hexo 个人博客","slug":"other/project/hexo","date":"2018-07-13T21:37:00.000Z","updated":"2018-08-03T02:05:36.716Z","comments":true,"path":"2018/07/14/other/project/hexo/","link":"","permalink":"http://blog.mrsuper.top/2018/07/14/other/project/hexo/","excerpt":"","text":"hexo 搭建属于自己的博客，比起那些免费博客大平台（CSDN、51 CTO、博客园、简书），自己搭建的总是那么彰显个性，也更具技术含量。更可以间接学习到 git 分支控制、SEO、百度收录、网站统计等等，何乐而不为之？ 相关资料 Hexo 中文 Github（国外代码仓库） 阿里云（服务器、域名） 主题皮肤 七牛云（资源库） 畅言（全名评论） Coding（国内代码仓库） Hexo 主要命令1. 服务器启动123hexo server# http://localhost:4000/ 2. 发布文章步骤12345# 创建hexo new [layout] &lt;title&gt;# 或发布hexo publish [layout] &lt;filename&gt; 3. 生成/部署12345# 生成博客hexo deploy -g# 或一键生成并发布（提交至远程 gh-pages 分支）hexo generate -d ISSUE1. 每次部署都要手动创建一次 CNAME 文件并提交12345678910# 不再使用一键部署命令hexo generate -d# 1.在本地保存一份 CNAME 文件# 2.先构建博客hexo generate# 3.然后复制到构建目录cp CNAME public/CNAME# 4.最后部署到 Github pages 分支hexo deploy 注意：每次部署都需要重复输入命令，太繁琐，可以将上面命令保存至 package.json 的 scripts 中，每次只运行 npm run build 即可。 123\"scripts\": &#123; \"build\": \"hexo generate &amp;&amp; cp CNAME public/CNAME &amp;&amp; hexo deploy\"&#125; 2. 目录正常但 Github 显示 404修改目录名可以，但不要轻易修改目录大小写，Github 有 DNS 缓存 已经过去半天，缓存还在 一天过去了，缓存还在 直接修改文件名吧，骚年 3. 生成部署时报出警告12warning: LF will be replaced by CRLF in tags/driving-car/index.html.The file will have its original line endings in your working directory. 相关 issue 12# 执行该命令即可git config --global core.autocrlf false 4. SEO 无效，百度基本 GG修改主题插件中的 _config.yml 文件 123456# 打开百度搜索search baidu: true# 打开百度统计plugins baidu_analytics: xxxx.... 但是半天过去了，效果还是没出来 一天快过去了，效果还是没出来 在项目根目录添加一个 robots.txt 空文件 修改域名，需要在 github 上把 CNAME 清除再指定可清除缓存 依旧无效果：github 禁止了百度蜘蛛 看这篇 使用 Coding 来解决方案 开启被百度收录，简书 百度站点管理 sitemap 插件","categories":[{"name":"Other","slug":"Other","permalink":"http://blog.mrsuper.top/categories/Other/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://blog.mrsuper.top/tags/hexo/"}]},{"title":"Axios 异步请求","slug":"other/http/axios","date":"2018-07-12T23:35:54.000Z","updated":"2018-08-03T02:05:36.715Z","comments":true,"path":"2018/07/13/other/http/axios/","link":"","permalink":"http://blog.mrsuper.top/2018/07/13/other/http/axios/","excerpt":"","text":"ajax 的出现，WEB 前端崛起，而 fetch 的出现，WEB 前端达到了一个新的高度。fetch 的优秀代表「 Axios 」，把 fetch 发挥得淋漓尽致，我已经在几个线上项目里用上 Axios，很顺手，很舒服。这篇文章记录使用 Axios 的一些注意事项与那些踩过的坑。 相关资料 Fetch API 文档 Axios 源码 下载1234yarn add axios# use npmnpm install --save axios 遵循 RESTful 风格 axios.get axios.post axios.put axios.delete 1. GET（获取）1234567891011121314151617181920212223import axios from 'axios'const id = 4// Get methodaxios.get(`/user/$&#123;id&#125;`).then(res =&gt; &#123; // callback... if (res.code === 200) &#123; // ...res.data &#125;&#125;)// 或者带参数，区别于 POST、PUT，需要使用 params 带参axios.get('/user', &#123; params: &#123; id &#125;&#125;).then((&#123; code, data &#125;) =&gt; &#123; // callback... if (code === 200) &#123; // ...data &#125;&#125;) 2. POST（创建）12345678910import axios from 'axios'const user = &#123; name: 'Super', age: 18&#125;// Post method// 不需要带 params 键，直接提交axios.post('/user', user).then(res =&gt; &#123; /* ... */ &#125;) 3. PUT（编辑）12345678import axios from 'axios'const id = 4const age = 16// Put method// 也是不需要带 paramsaxios.put(`/user/$&#123;id&#125;`, &#123; age &#125;).then(res =&gt; &#123; /* ... */ &#125;) 4. DELETE（删除）123456789import axios from 'axios'const id = 0// Delete method// 处理异常使用 catchaxios.delete(`/user/$&#123;id&#125;`) .then(res =&gt; &#123; /* ... */ &#125;) .catch(() =&gt; &#123; /* ... */ &#125;) 合并请求 axios.all axios.spread 1234567891011121314151617import axios from 'axios'const id1 = 4const id2 = 6function getUser1 () &#123; return axios.get(`/user/$&#123;id1&#125;`)&#125; function getUser2 () &#123; return axios.get('/user/$&#123;id2&#125;')&#125; axios.all([getUser1(), getUser2()]) .then(axios.spread((user1, user2) =&gt; &#123; // callback... &#125;)) axios 配置 axios(config) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118&#123; // 请求路径 url: '/user', // 方法名 method: 'get', // default // 绝对路径，请求路径前缀 baseURL: 'https://some-domain.com/api/', // 发送请求前修改资源内容 // 只适用于 POST、PUT、PATCH 方法 // 修改请求头在这里完成 // 必须返回 Array、String、Buffer、ArrayBuffer、FormData、Stream transformRequest: [(data, headers) =&gt; &#123; return data &#125;], // 响应后修改资源内容 // 被 then、catch 接受 transformResponse: [data =&gt; &#123; return data &#125;], // 自定义请求头 headers: &#123; 'X-Requested-With': 'XMLHttpRequest' &#125;, // 请求参数 // 必修是普通 Object、URLSearchParams params: &#123; id: 4 &#125;, // 序列化参数 // 参考1：https://www.npmjs.com/package/qs // 参考2：http://api.jquery.com/jquery.param/ paramsSerializer: params =&gt; &#123; return Qs.stringify(params, &#123; arrayFormat: 'brackets' &#125;) &#125;, // 请求携带的数据 // 只适用于 POST、PUT、PATCH 方法 // 只能为以下类型之一： // 数据类型：String、Plain object、ArrayBuffer、 // ArrayBufferView、URLSearchParams // 浏览器端: FormData、File、Blob // NODE.js 环境: Stream、Buffer data: &#123; name: 'Super' &#125;, // 超时时间设置 timeout: 2000, // 是否使用凭证 withCredentials: false, // 默认 false // 测试适配器 adapter: config =&gt; &#123; /* ... */ &#125;, // 凭证数据、请求头凭证数据 auth: &#123; username: 'super', password: 'superwas18' &#125;, // 声明服务器响应的数据类型 // 选项有：'arraybuffer'、'blob'、'document'、'json'、'text'、'stream' responseType: 'json', // 默认 json // token cookie 名 xsrfCookieName: 'XSRF-TOKEN', // 默认 XSRF-TOKEN // 传递 token 的请求头 cookie 名 xsrfHeaderName: 'X-XSRF-TOKEN', // 默认 X-XSRF-TOKEN // 上传进度回调 onUploadProgress: progressEvent =&gt; &#123; &#125;, // 下载进度回调 onDownloadProgress: progressEvent =&gt; &#123; &#125;, // 定义响应头数据最大长度 maxContentLength: 2000, // 设置响应的状态 validateStatus: status =&gt; &#123; return status &gt;= 200 &amp;&amp; status &lt; 300; // 默认 大于 200 并且 小于 300 &#125;, // 重定向最大数量 maxRedirects: 5, // 默认 5 // socket 路径 socketPath: null, // 默认 null // 自定义代理连接模式 httpAgent: new http.Agent(&#123; keepAlive: true &#125;), httpsAgent: new https.Agent(&#123; keepAlive: true &#125;), // 自定义代理信息 proxy: &#123; host: '127.0.0.1', port: 9000, auth: &#123; username: 'mikeymike', password: 'rapunz3l' &#125; &#125;, // 取消 token 回调 cancelToken: new CancelToken(cancel =&gt; &#123; &#125;)&#125;","categories":[{"name":"Other","slug":"Other","permalink":"http://blog.mrsuper.top/categories/Other/"},{"name":"HTTP","slug":"Other/HTTP","permalink":"http://blog.mrsuper.top/categories/Other/HTTP/"}],"tags":[{"name":"axios","slug":"axios","permalink":"http://blog.mrsuper.top/tags/axios/"}]},{"title":"基于 create-react-app 搭建开发环境","slug":"js/react/create-react-app","date":"2018-07-08T17:47:11.000Z","updated":"2018-09-06T06:58:42.057Z","comments":true,"path":"2018/07/09/js/react/create-react-app/","link":"","permalink":"http://blog.mrsuper.top/2018/07/09/js/react/create-react-app/","excerpt":"","text":"create-react-app 据说是最好的 react 脚手架，比起 vue-cli 的全家桶，实在不敢恭维，需要自己配置的工序还是太多太多了。所以在这里记录使用的步骤，以供以后翻阅。这次配合 Ant Desgin Mobile 搭建移动端开发环境，还有 Axios 作异步请求。 0. 相关资料 create-react-app github React 中文 Ant Desgin Mobile React Router dom 中文 Redux 中文 项目源码 1. 下载与安装1234yarn create react-app react-demo# npmnpm init react-app react-demo 2. 引入 and-desgin-mobile下载1234yarn add antd-mobile# 按需加载yarn add -D react-app-rewired babel-plugin-import 修改启动配置123456789// package.json// ...\"scripts\": &#123; \"start\": \"react-app-rewired start\", \"build\": \"react-app-rewired build\", \"test\": \"react-app-rewired test --env=jsdom\", \"eject\": \"react-app-rewired eject\"&#125;,// ... 添加配置文件在根目录添加 ./config-overrides.js 文件，内容如下：12345const &#123; injectBabelPlugin &#125; = require('react-app-rewired')module.exports = function override(config, env) &#123; config = injectBabelPlugin(['import', &#123; libraryName: 'antd-mobile', style: 'css' &#125;], config) return config&#125; 3. 引入 react-router-dom下载1yarn add -D react-router-dom 修改 ./src/main.js 文件 ./src/views/：存放视图页面 ./src/router/：存放路由构建工具（暂时用不到，后期需要做权限分配路由） 12345678910111213141516import &#123; BrowserRouter as Router, Route&#125; from 'react-router-dom'import Login from './views/login'import Main from './views/main'ReactDOM.render( &lt;Router&gt; &lt;div&gt; &lt;Route exact path=\"/\" component=&#123; Login &#125; /&gt; &lt;Route path=\"/main\" component=&#123; Main &#125; /&gt; &lt;/div&gt; &lt;/Router&gt;, document.getElementById('root')) 4. 引入 redux下载1234yarn add redux# 配合路由需要用到 react-reduxyarn add react-redux 修改 ./src/main.js 文件12345678910111213141516171819202122import &#123; Provider &#125; from 'react-redux'import &#123; createStore &#125; from 'redux'import m3app from './reducers'const store = createStore(m3app)// 订阅-发布 模式// state 变化时触发store.subscribe(() =&gt; &#123; console.log(store.getState())&#125;)ReactDOM.render( &lt;Provider store=&#123; store &#125;&gt; &lt;Router&gt; &lt;div&gt; &lt;Route exact path=\"/\" component=&#123; Login &#125; /&gt; &lt;Route path=\"/main\" component=&#123; Main &#125; /&gt; &lt;/div&gt; &lt;/Router&gt; &lt;/Provider&gt;, document.getElementById('root')) reducers ./reducers/：存放 redux 数据的接收-处理机制 具体使用操作，请看redux 使用步骤 123456789101112// ./reducers/index.jsimport &#123; combineReducers &#125; from 'redux'import main from './main'import user from './user'const m3app = combineReducers(&#123; main, user&#125;)export default m3app 123456789101112// ./reducers/main.jsconst main = (state = &#123; tab: 'Home' &#125;, action) =&gt; &#123; switch (action.type) &#123; case 'SELECTED_TAB': return &#123; ...state, tab: action.tab &#125; default: return state &#125;&#125;export default main","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://blog.mrsuper.top/categories/JavaScript/"},{"name":"React","slug":"JavaScript/React","permalink":"http://blog.mrsuper.top/categories/JavaScript/React/"}],"tags":[{"name":"react","slug":"react","permalink":"http://blog.mrsuper.top/tags/react/"},{"name":"create-react-app","slug":"create-react-app","permalink":"http://blog.mrsuper.top/tags/create-react-app/"}]},{"title":"Vuex 的设计之美","slug":"js/vue/vuex","date":"2018-06-25T21:40:15.000Z","updated":"2018-08-03T02:05:36.711Z","comments":true,"path":"2018/06/26/js/vue/vuex/","link":"","permalink":"http://blog.mrsuper.top/2018/06/26/js/vue/vuex/","excerpt":"","text":"Vuex 是一个专为 Vue.js 应用程序开发的状态管理工具。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。Vuex 灵感来自 Flux 和 Redux，青出于蓝，更上一层楼。 相关教程 Vuex 官网 1. 准备工作一般使用 vue-cli v3 搭建脚手架时勾选 vuex 即可vue-cli v2 需要手动下载依赖 12345# 下载依赖yarn add vuex# 使用 npmnpm install vuex --save 2. 仓库（Store）也可以叫数据容器，用来放置项目的所有共享数据。每个项目只允许有一个仓库（多个也可以，不推荐酱紫干，难维护，复杂度高）。 1234567891011121314// vue 中使用，通常在入口文件（main.js）中引入import Vue from 'vue'import Vuex from 'vuex'const store = new Vuex.Store(&#123; // state... // mutation... // action...&#125;)const app = new Vue(&#123; // ... store, // ...&#125;) 3. 状态（State）也可以叫数据，共享数据，只是视图（页面显示的数据）都是因 State 的变化而变化，所以称它为“状态”（State）获取方式比较直接 store.state.[name]，不能直接设置值，比如 store.state.name = &#39;Super&#39; 12345678# 在 vue 的组件中使用，获取 this.name 即可export default &#123; // ... computed: &#123; name () &#123; return this.$store.state.name &#125; &#125;, // ...&#125; mapState 辅助函数放于组件 computed 函数中 123456789101112131415161718// 在组件中使用import &#123; mapState &#125; from 'vuex'export default &#123; // ... computed: mapState(&#123; // 箭头函数 name: state =&gt; state.name, // 换变量名，'name' 等同于上面取值 myName: 'name', // 使用 this getFullName (state) &#123; return `$&#123;this.surname&#125; - $&#123;state.name&#125;` &#125; &#125;)&#125; 当命名相同时，可直接使用数据形式 123456789import &#123; mapState &#125; from 'vuex'export default &#123; // ... computed: mapState([ 'name' ]), // ...&#125; 或者 1234567891011121314import &#123; mapState &#125; from 'vuex'export default &#123; // ... computed: &#123; surname: () &#123; /* ... */ &#125;, // es6 解构 ...mapState([ 'name' ]) &#125;, // ...&#125; 4. 获取状态（Getter）一般用在获取那些需要把数据（State）修饰过的数据。 1234567891011121314151617181920const store = new Vuex.Store(&#123; state: &#123; surname: 'Lin', name: 'Super' &#125;, getters: &#123; surname: state =&gt; &#123; return state.surname.toUpperCase() &#125;, // 第二个参数 fullName: (state, getters) =&gt; &#123; return getters.surname + state.name &#125;, // 带参数 // 传入 Upper、Lower，自定义大小写姓名 getFullName: (state, getters) =&gt; case =&gt; &#123; return getters.fullName[`to$&#123;case&#125;Case`]() &#125; &#125;&#125;) 在组件中使用 this.$store.getters.surname this.$store.getters.fullName this.$store.getters.getFullName(&#39;Upper&#39;) mapGetters 辅助函数放于组件 computed 函数中 123456789101112131415161718import &#123; mapGetters &#125; from 'vuex'export default &#123; // ... computed: &#123; ...mapGetters([ 'surname', 'fullName', 'getFullName' ]), // 改名 ...mapGetters(&#123; getName: 'getFullName' &#125;) &#125;, // ...&#125; 5. 突变（Mutation）前面说过修改 State 不能直接以赋值的方式，Vuex 这里修改 State 需要提交一个突变（Mutation），以便于记录状态的变化过程。格式：一个字符串的 事件类型（type），一个 回调函数（handle），回调用来修改状态「 突变必须是同步函数，否则异步函数里状态变更无效 」 123456789101112131415161718192021const store = new Vuex.Store(&#123; state: &#123; name: 'Super', age: 18 &#125;, mutations: &#123; // 无参 'happy new year' (state) &#123; // 变更状态 state.age++ &#125;, // 带参 rename (state, newName) &#123; state.name = newName &#125;, // 对象风格 changeOfAge (state, secret) &#123; state.age = secret.age &#125; &#125;&#125;) 在组件中调用 this.$store.commit(&#39;happy new year&#39;) this.$store.commit(&#39;rename&#39;, &#39;素伯&#39;) this.$store.commit({ type: &#39;changeOfAge&#39;, age: 18 }) mapMutations 辅助函数放于组件中 methods 方法中 123456789101112131415161718192021import &#123; mapMutations &#125; from 'vuex'export default &#123; // ... methods: &#123; ...mapMutations([ // 映射：this.$store.commit('happy new year') // 使用：this['happy new year']() 'happy new year', // 自动支持带参 'rename' ]), // 改名 ...mapMutations(&#123; trueAge: 'changeOfAge' &#125;) &#125;, // ...&#125; 6. 动作（Action）与 Mutation 类型，但它提交的是 Mutation，支持异步操作「 与 React 中的 Redux 主要区别，Redux 没有这个概念，复杂度飙升 」 12345678910111213141516171819202122232425262728293031323334const store = new Vuex.Store(&#123; state: &#123; name: 'Super', age: 18 &#125;, mutations: &#123; 'happy new year' (state) &#123; // 变更状态 state.age++ &#125;, rename (state, newName) &#123; state.name = newName &#125;, changeOfAge (state, secret) &#123; state.age = secret.age &#125; &#125;, actions: &#123; 'happy new year' (content) &#123; content.commit('happy new year') &#125;, // es6 解构 rename (&#123; state, commit, getters, actions &#125;, name) &#123; commit('rename', name) &#125;, changeOfAge (&#123; commit &#125;, secret) &#123; // 好像怪怪的 // 让我想想 5 秒钟 setTimeout(() =&gt; &#123; commit('changeOfAge', secret) &#125;, 5000) &#125; &#125;&#125;) 在组件中使用 this.$store.dispatch(&#39;happy new year&#39;) this.$store.dispatch(&#39;rename&#39;, &#39;素伯&#39;) this.$store.dispatch({ type: &#39;changeOfAge&#39;, age: 18 }) mapActions 辅助函数放于组件中 methods 方法中，与 Mutation 一毛一样 12345678910111213141516import &#123; mapActions &#125; from 'vuex'export default &#123; // ... methods: &#123; ...mapActions([ 'happy new year', 'rename' ]), // 改名 ...mapActions(&#123; trueAge: 'changeOfAge' &#125;) &#125;&#125; 7. 模块（Module）由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。 123456789101112131415161718192021222324const moduleSuper &#123; state: &#123; name: 'Super' &#125;, mutations: &#123; /* ... */ &#125;, actions: &#123; /* ... */ &#125;, getters: &#123; /* ... */ &#125;&#125;const moduleSubo = &#123; state: &#123; name: '素伯' &#125;, mutations: &#123; /* ... */ &#125;, actions: &#123; /* ... */ &#125;&#125;const store = new Vuex.Store(&#123; modules: &#123; Super: moduleSuper, Subo: moduleSubo &#125;&#125;)// moduleSuper 的 name 状态store.state.Super.name // moduleSubo 的 name 状态store.state.Subo.name 局部与全局状态 Mutation 与 Getter 接收第一个参数是局部 State 对于 Action 的 context 中暴露的 state 为局部，rootState、rootGetters 为全局 Getter 第二参数为局部 getters，第三个参数 rootState 为全局 命名空间 如果在模块中不指定命名空间，那么 getter、dispatch、commit 不受局部影响，调用时当全局调用，如：this.$store.commit(&#39;moduleSuper: happy new year&#39;) 如在 modules 中加上：namespaced: true 指明开启命名空间，那么调用就得带上命名空间 如：this.$store.Super.commit(&#39;happy new year&#39;) 在命名空间里声明全局 Action，在 actions 方法中加上 root: true 即可 使用辅助函数比较繁琐 12345678910111213141516export default &#123; // ... computed: &#123; ...mapState(&#123; a: state =&gt; state.some.nested.module.a, b: state =&gt; state.some.nested.module.b &#125;) &#125;, methods: &#123; ...mapActions([ 'some/nested/module/foo', 'some/nested/module/bar' ]) &#125;, // ...&#125; 可以设置第一个参数为模块路径 12345678910111213141516export default &#123; // ... computed: &#123; ...mapState('some/nested/module', &#123; a: state =&gt; state.a, b: state =&gt; state.b &#125;) &#125;, methods: &#123; ...mapActions('some/nested/module', [ 'foo', 'bar' ]) &#125;, // ...&#125; createNamespacedHelpers 辅助函数123456789101112131415161718192021import &#123; createNamespacedHelpers &#125; from 'vuex'const &#123; mapState, mapActions&#125; = createNamespacedHelpers('some/nested/module')export default &#123; computed: &#123; ...mapState(&#123; a: state =&gt; state.a, b: state =&gt; state.b &#125;) &#125;, methods: &#123; ...mapActions([ 'foo', 'bar' ]) &#125;&#125;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://blog.mrsuper.top/categories/JavaScript/"},{"name":"Vue","slug":"JavaScript/Vue","permalink":"http://blog.mrsuper.top/categories/JavaScript/Vue/"}],"tags":[{"name":"vuex","slug":"vuex","permalink":"http://blog.mrsuper.top/tags/vuex/"}]},{"title":"Vue-cli v3 新特性","slug":"js/vue/vue-cli-3","date":"2018-06-24T12:38:56.000Z","updated":"2018-08-03T02:05:36.711Z","comments":true,"path":"2018/06/24/js/vue/vue-cli-3/","link":"","permalink":"http://blog.mrsuper.top/2018/06/24/js/vue/vue-cli-3/","excerpt":"","text":"前端三大主流框架，Angular、Vue、React，Vue 属于中等难度，作者是国内华人。Vue 算是我上手最快，坑最少的一门技术，也是唯一一门可以看着文档，直接开发项目上线。因为有官方出品的 vue-cli 全家桶套餐，让你不再关心琐粹，安心写你业务逻辑。Vue 发展迅速，vue-cli 已经第三版上线，比第二版更清爽，耦合性更低。不过我建议：新手还是使用 v2 的 vue init webpack [project name]，第三版默认使用 Yarn，vue create [project name] 相关资料 vue-cli 官网 webpack-chain v3，配置时需要用上，vue-cli 自带 yarn，vue-cli 默认 12345# 安装全局yarn global add @vue/cli# 使用 npmnpm install -g @vue/cli 1. 创建项目与配置1234vue create new-vue-project# 需要注意的是 Git 自带的 git-bash 命令行在 windows 10 上用不了脚手架配置功能# 我是直接用 windows 自带的 cmd 进行配置脚手架 使用上面命令之后，会出现以下配置界面，使用方向键（上、下），回车键（Enter）确定选项。 12345Vue CLI v3.0.0-rc.3? Please pick a preset: preset.json (vue-router, vuex, sass, babel, pwa, eslint) default (babel, eslint)&gt; Manually select features 配置说明： 第 3 行：这个是我这台机之前 vue create 创建过项目，把我的配置保存至 ~/vuerc/preset.json 中，所以下次创建项目的时候会罗列出本机创建过的配置文件，供你选择 第 4 行：默认配置，只选择 babel、eslint 插件 第 5 行：自己手动配置 2. 选择配置我们选择手动配置，会弹出以下窗口，也提示了我们使用方向键（上、下）移动，空格（Space）选择配置，回车（Enter）确定配置，A 按键全选，I 按键反选1234567891011121314Vue CLI v3.0.0-rc.3? Please pick a preset: Manually select features? Check the features needed for your project: (Press &lt;space&gt; to select, &lt;a&gt; to toggle all, &lt;i&gt; to invert selection)&gt;(*) Babel ( ) TypeScript ( ) Progressive Web App (PWA) Support ( ) Router ( ) Vuex ( ) CSS Pre-processors (*) Linter / Formatter ( ) Unit Testing ( ) E2E Testing 配置说明： 第 6 行：渐进式增强体验（PWA）——请看《第一本 PWA 中文书》，PWA 中文网 其他的都是些常用的 loader、中间件、样式预处理器、代码风格、功能测试、项目测试等 3. 勾选之后的配置括号中，大写为默认值，比如 (Y/n) 默认是 yes，反之 (y/N) 默认是 no 1234567891011121314151617181920212223242526272829303132333435363738# 是否使用组件类样式语法? Use class-style component syntax? (Y/n)# 在 TypeScirpt 中自动检测 polyfills? Use Babel alongside TypeScript for auto-detected polyfills? (Y/n)# 选择 css 预处理器? Pick a CSS pre-processor (PostCSS, Autoprefixer and CSS Modules are supported by default): (Use arrow keys)&gt; SCSS/SASS LESS Stylus# 选择 eslint 配置? Pick a linter / formatter config: (Use arrow keys)&gt; TSLint ESLint with error prevention only ESLint + Airbnb config ESLint + Standard config ESLint + Prettier# eslint 检测方式（保存、提交版本）? Pick additional lint features: (Press &lt;space&gt; to select, &lt;a&gt; to toggle all, &lt;i&gt; to invert selection)&gt;(*) Lint on save ( ) Lint and fix on commit# 测试工具? Pick a unit testing solution: (Use arrow keys)&gt; Mocha + Chai Jest# 测试方案? Pick a E2E testing solution: (Use arrow keys)&gt; Cypress (Chrome only) Nightwatch (Selenium-based) 4. 配置完之后询问这些配置保存各自配置中，还是保存至 package.json 中 12345? Where do you prefer placing config for Babel, PostCSS, ESLint, etc.? (Use arrow keys)&gt; In dedicated config files In package.json 5. 是否保存预设配置如果输入 y，确定保存的话，会让你输入一个文件名字，它将保存在 ~/vuerc 目录中。那么下次 创建时，会出现在预设选项中 1234? Save this as a preset for future projects? (y/N)# yes 的话? Save preset as: 配置完成：这样下来，全部完成脚手架配置，就可以进入项目目录，直接启动。这里不再需要进入项目中，进行安装目录 123456# 进入项目目录cd new-vue-project# 启动yarn serve# http://localhost:8080 6. wepack 配置在项目中新建 vue.config.js 文件，我爱的配置如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546const path = require('path')const apiMocker = require('webpack-api-mocker')function resolve (dir) &#123; return path.join(__dirname, dir)&#125;module.exports = &#123; chainWebpack: config =&gt; &#123; // alias config.resolve.alias .set('assets', resolve('src/assets')) .set('images', resolve('src/assets/images')) .set('scss', resolve('src/assets/scss')) .set('components', resolve('src/components')) .set('mock', resolve('src/mock')) .set('utils', resolve('src/utils')) .set('views', resolve('src/views')) &#125;, // mock devServer: &#123; // 热加载 hot: true, // 外部可使用 host: '0.0.0.0', // 请求头 headers: &#123; 'APP-Token': 'aliyun-oss-cdn-path', 'APP-Time': '2018-6-23 23:49:33' &#125;, // 代理 proxy: &#123; '/api': &#123; target: 'http://localhost:8080', pathRewrite: &#123; '^/api': '' &#125; &#125; &#125;, // 启动服务 before: app =&gt; &#123; apiMocker(app, path.resolve('mock/index.js'), &#123;&#125;) &#125; &#125;&#125;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://blog.mrsuper.top/categories/JavaScript/"},{"name":"Vue","slug":"JavaScript/Vue","permalink":"http://blog.mrsuper.top/categories/JavaScript/Vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://blog.mrsuper.top/tags/vue/"},{"name":"zero-based","slug":"zero-based","permalink":"http://blog.mrsuper.top/tags/zero-based/"}]},{"title":"redux 使用步骤","slug":"js/react/zero-based-redux","date":"2018-06-17T17:02:35.000Z","updated":"2018-08-03T02:05:36.710Z","comments":true,"path":"2018/06/18/js/react/zero-based-redux/","link":"","permalink":"http://blog.mrsuper.top/2018/06/18/js/react/zero-based-redux/","excerpt":"","text":"跟着 Redux 的中文文档，一步一步实现自己的第一个 React 项目，发现 Redux 的原理与特性太难理解了。初始数据不够直观（无从下手）、各种数据的穿插太乱（数据经常走丢，找不着）、同步与异步太笼统（不够明确区分两者有啥区别）。 官网的定义 Redux 是 JavaScript 状态容器，提供可预测化的状态管理。 (如果你需要一个 WordPress 框架，请查看 Redux Framework。) 可以让你构建一致化的应用，运行于不同的环境（客户端、服务器、原生应用），并且易于测试。不仅于此，它还提供 超爽的开发体验，比如有一个时间旅行调试器可以编辑后实时预览。 Redux 除了和 React 一起用外，还支持其它界面库。 它体小精悍（只有 2kB，包括依赖）。 其他教程 Redux 中文文档 Redux 作者自己出的视频教程 1. 准备工作12345# 安装yarn add redux# 配合路由、多页面数据交互时需要 react-reduxyarn add react-redux 2. 最小的例子（有点诡异）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/* * 因为初始数据不够直观，需要我们自己定义一个，然后心里记住 * 现在我们要定义一个人出生，以下信息会随着年纪地增长而变化 * person = &#123; name: 'Super', age: 18 &#125; */// 引入仓库构造器import &#123; createStore &#125; from 'redux'// 创建仓库，并带有接受请求的回调方法// 第一个参数可以初始化数据const store = createStore((person = &#123; name: 'baby', age: 0 &#125;, require) =&gt; &#123; // 判断请求的类型 switch (require.type) &#123; case '局长，改个名': // 禁止修改原有对象数据，应当返回一个新的对象，旧数据可以全部丢给新对象 return &#123; ...person, name: action.name &#125; case '不知不觉，过了一年': case '不知不觉，又过了一年': return &#123; ...person, age: person.age + 1 &#125; default: return person &#125;&#125;)// 监听数据变化store.subscribe(() =&gt; &#123; console.log(store.getState())&#125;)// 有那么一天，有个小胖娃出生了console.log(store.getState())// 输出 &#123; name: 'baby', age: 0 &#125;// 出生了，就得给 baby 取个名字// 触发数据，type 字段固定，其他的不限// 按照规定请求以下即可store.dispatch(&#123; type: '局长，改个名', name: 'Super' &#125;)// 输出 &#123; name: 'Super', age: 0 &#125;// 我懵懵懂懂过了一年store.dispatch(&#123; type: '不知不觉，过了一年' &#125;)// 输出 &#123; name: 'Super', age: 1 &#125;store.dispatch(&#123; type: '不知不觉，又过了一年' &#125;)// 输出 &#123; name: 'Super', age: 2 &#125; 3. 同步示例要不先看看这篇文章？ 组件之间的数据（store）交互需要用到 react-redux 中的 connect 方法，将需要的个别数据（state）拿到，还有一些触发器（dispatch）串联在一起。现在为上面例子的 Baby 创建一个组件，名为 /components/baby/index.js，内容如下： 123456789101112131415161718import React, &#123; Component &#125; from 'react'class Baby extends Component &#123; render () &#123; return ( &lt;&gt; &lt;div&gt;我叫 baby&lt;/div&gt; &lt;div&gt;今年 1 岁&lt;/div&gt; &lt;button onClick=&#123;&#125;&gt; 我懵懵懂懂过了一年 &lt;/button&gt; &lt;/&gt; ) &#125;&#125;export default Baby 很明显，上面的例子名字写死了，年龄也不能通过按钮累加，改成如下即可通过 this.props 对象取到你所想要的。 1234567891011121314151617181920212223242526272829303132333435363738394041424344import React, &#123; Component &#125; from 'react'// 引入 react-reduximport &#123; connect &#125; from 'react-redux'class Baby extends Component &#123; render () &#123; return ( &lt;&gt; &lt;div&gt;我叫 &#123; this.props.name &#125;&lt;/div&gt; &lt;div&gt;今年 &#123; this.props.age &#125; 岁&lt;/div&gt; &lt;button onClick=&#123; this.props.after_a_year &#125;&gt; 我懵懵懂懂过了一年 &lt;/button&gt; &lt;/&gt; ) &#125;&#125;/* * 修改返回对象 * connect 带有 2 个参数 * 1. state: 指明你需要用到哪些数据 * 2. dispatch: 定义方法，可以在方法里面使用触发器 */export default connect( // 指明 state =&gt; &#123; return &#123; name: state.name, age: state.age &#125; &#125;, // 定义 dispatch =&gt; &#123; return &#123; after_a_year: () =&gt; &#123; dispatch(&#123; type: '不知不觉，过了一年' &#125;) &#125; &#125; &#125;)(Baby) 4. 异步示例异步操作，其实就是同步的三个状态，每个状态调用（还是 dispatch）不同的触发器。三个状态指的是：请求开始1，请求结束（成功2 或失败3）；而不是请求开始、请求中、请求结束（很容易误解）。Baby 爸妈去局里改名字啦~改改上面的例子： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import React, &#123; Component &#125; from 'react'import &#123; connect &#125; from 'react-redux'class Baby extends Component &#123; render () &#123; return ( &lt;div&gt; &lt;div&gt;我叫 &#123; this.props.name &#125;&lt;/div&gt; &lt;div&gt;今年 &#123; this.props.age &#125; 岁&lt;/div&gt; &lt;button onClick=&#123; this.props.after_a_year &#125;&gt; 我懵懵懂懂过了一年 &lt;/button&gt; &lt;button onClick=&#123; () =&gt; this.props.rename('李狗蛋') &#125;&gt; 爸妈给 Boby 名字改成“李狗蛋” &lt;/button&gt; &lt;div/&gt; ) &#125;&#125;// 提取出 state 与 dispatchconst mapStateToProps = state =&gt; &#123; return &#123; name: state.name, age: state.age &#125;&#125;const mapDispatchToProps = dispatch =&gt; &#123; return &#123; after_a_year: () =&gt; &#123; dispatch(&#123; type: '不知不觉，过了一年' &#125;) &#125;, // 去局里改名字 rename: name =&gt; &#123; // 局长收到他们的请求，把“李狗蛋”录入系统里，需要半个钟全国的系统才能同步 // 暂时先显示改名中 dispatch(&#123; type: '局长，改个名', name: 'Baby（改名中）' &#125;) setTimeout(() =&gt; &#123; if ('如果成功') &#123; // 全世界都知道 Baby 叫李狗蛋了 dispatch(&#123; type: '局长，改个名', name: '李狗蛋' &#125;) &#125; else &#123; // 如果失败 dispatch(&#123; type: '局长，改个名', name: 'Baby（改名失败）' &#125;) &#125; &#125;, 30 * 60 * 1000) &#125; &#125;&#125;export default connect( mapStateToProps, mapDispatchToProps)(Baby)","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://blog.mrsuper.top/categories/JavaScript/"},{"name":"React","slug":"JavaScript/React","permalink":"http://blog.mrsuper.top/categories/JavaScript/React/"}],"tags":[{"name":"react","slug":"react","permalink":"http://blog.mrsuper.top/tags/react/"},{"name":"redux","slug":"redux","permalink":"http://blog.mrsuper.top/tags/redux/"}]},{"title":"基于 Docker 搭建 ShowDoc","slug":"linux/docker/showdoc","date":"2018-06-16T20:11:05.000Z","updated":"2018-07-31T09:08:08.824Z","comments":true,"path":"2018/06/17/linux/docker/showdoc/","link":"","permalink":"http://blog.mrsuper.top/2018/06/17/linux/docker/showdoc/","excerpt":"","text":"ShowDoc 官网给出的一句话：一个非常适合 IT 团队的在线API文档、技术文档工具；团队权限管理机制让团队良好地协同编写文档；超过 6000+ 互联网团队正在使用 ShowDoc。 1234567891011121314# 下载源码cd ~ &amp;&amp; git clone https://github.com/star7th/showdoc &amp;&amp; cd showdoc# 构建镜像docker image build -t showdoc .# 生成容器并运行docker container run --name super-showdoc -p 4999:80 showdoc# 打标签docker image tag showdoc linzechao/super-showdoc:0.0.1# 提交 DockerHubdocker image push linzechao/super-showdoc:0.0.1 注意：遇到的坑 镜像下载很快（香港服务器），不需要换镜像源，如需要则添加以下内容至/etc/docker/daemon.json文件即可： 123&#123; \"registry-mirrors\": [\"https://registry.docker-cn.com\"]&#125; 构建镜像时报错：E: Package &#39;libpng12-dev&#39; has no installation candidate。换了镜像源还是报这个，索性将Dockerfile中的libpng12-dev删掉，再构建镜像，再生成容器运行，一切顺利进行。 ShowDoc 搭建完成 DockerHub 镜像","categories":[{"name":"Linux","slug":"Linux","permalink":"http://blog.mrsuper.top/categories/Linux/"},{"name":"Docker","slug":"Linux/Docker","permalink":"http://blog.mrsuper.top/categories/Linux/Docker/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://blog.mrsuper.top/tags/linux/"},{"name":"docker","slug":"docker","permalink":"http://blog.mrsuper.top/tags/docker/"}]},{"title":"“开源”豪门盛宴","slug":"other/project/platform","date":"2018-06-15T13:07:00.000Z","updated":"2018-07-31T09:08:08.829Z","comments":true,"path":"2018/06/15/other/project/platform/","link":"","permalink":"http://blog.mrsuper.top/2018/06/15/other/project/platform/","excerpt":"","text":"开放源代码（Open source code）也称为源代码公开，指的是一种软件发布模式。一般的软件仅可取得已经过编译的二进制可执行档，通常只有软件的作者或著作权所有者等拥有程序的原始码。有些软件的作者会将原始码公开，此称之为“源代码公开”，但这并不一定符合“开放原代码”的定义及条件，因为作者可能会设定公开原始码的条件限制，例如限制可阅读原始码的对象、限制衍生品等。 版本仓库开放式平台 GitHub Bitbucket Coding 开源工具 GitLab Gogs 镜像仓库 NPM 淘宝 Cnpm Yarn DockerHub 资源仓库 Gravatar全球头像共享平台，绑定邮箱地址，那么其他平台（DockerHub）对接后即可实现头像共享。 七牛云 阿里 iconfont CDN BootCDN 资源库 Font Awesome ECharts 图形图表 项目协助 Trello 看板 ShowDoc 接口文档 SEO 百度站点收录 实时推送工具（密码：ksa2） 工具教程 百度统计 其他工具 icon 生成器 二维码生成器","categories":[{"name":"Other","slug":"Other","permalink":"http://blog.mrsuper.top/categories/Other/"}],"tags":[{"name":"other","slug":"other","permalink":"http://blog.mrsuper.top/tags/other/"}]},{"title":"Vue 回炉之路","slug":"js/vue/zero-based-vue","date":"2018-05-19T17:08:35.000Z","updated":"2018-08-03T02:05:36.711Z","comments":true,"path":"2018/05/20/js/vue/zero-based-vue/","link":"","permalink":"http://blog.mrsuper.top/2018/05/20/js/vue/zero-based-vue/","excerpt":"","text":"Vue 算是我第一个感到强大的框架了，社区活跃度高，第三方插件支持力度大，拥有自己专属的“全家桶套餐”。vue-cli 自动构建项目，第三版还支持自定义构建脚手架，更新快，维护快。 官网 vue 中文 常用接口 API1、数据绑定（v-bind）数据绑定使用 v-bind:[property]，缩写 :[property]。 1234567&lt;!-- 绑定图片的 src 属性 --&gt;&lt;src :src=\"imgSrc\" alt=\"这是一张萌萌的小图片\"&gt;&lt;!-- 循环数据时，必须绑定的 key 属性 --&gt;&lt;ol v-for=\"&#123; id, name &#125; in Person\"&gt; &lt;li :key=\"id\"&gt;&#123;&#123; name &#125;&#125;&lt;/li&gt;&lt;/ol&gt; 2、事件绑定（v-on）事件绑定使用 v-on:[event]，缩写 @[event]。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://blog.mrsuper.top/categories/JavaScript/"},{"name":"Vue","slug":"JavaScript/Vue","permalink":"http://blog.mrsuper.top/categories/JavaScript/Vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://blog.mrsuper.top/tags/vue/"},{"name":"zero-based","slug":"zero-based","permalink":"http://blog.mrsuper.top/tags/zero-based/"}]},{"title":"从零开始搭建 React 开发环境","slug":"js/react/zero-based-react","date":"2018-05-09T20:47:14.000Z","updated":"2018-08-03T02:05:36.710Z","comments":true,"path":"2018/05/10/js/react/zero-based-react/","link":"","permalink":"http://blog.mrsuper.top/2018/05/10/js/react/zero-based-react/","excerpt":"","text":"本文章讲解的是如何零基础搭建 React 的 Windows 开发环境。前不久得知 dva（React 开发全家桶）的坑不少，看来这事值得。一步一脚印，一拜一菩提。珍贵的不是有勇气开始，而是有毅力坚持。 github 源码参考 搭建步骤： Yarn Webpack / webpack-dev-server React / react-dom Babel Andt Mobile style-loader / css-loader Mock / webpack-api-mocker react-router-dom / react-router sass-loader esLint-loader Redux / react-redux 1. Yarn我使用 Yarn 包管理器，体验上确实比 npm/cnpm 安装与更新更快，更便捷，维护起来也比较轻松。与 npm（由 Nodejs 安装自带）一样需要安装 exe 程序，下载地址。常用命令也就那几个，但要从 npm 的习惯中抽离出来是需要一段时间来过渡。 npm，yarn 以及 pnpm 的不同之处 1234567891011121314# 安装完成后，查看版本号yarn -v# 初始化项目yarn init# 添加依赖包至 package.json 的 dependencies 中yarn add react react-dom# 添加至 devDependencies 中yarn add -D webpack# 安装全局格式yarn --global add webpack-cli 2. Webpack前端自动化开发工具已经烂大街了，从 Grunt 到 Gulp，再到我现在使用的 Webpack ，前端技术更新太快，一浪拍一浪，胜出的往往是些经得起猿媛们折腾的。 这位看官，请往这边走 3. React基于步骤 2. Webpack 的 ./index.html 文件，添加一个 id 为 root 的 div，如下： 12345&lt;body&gt; &lt;div id=\"root\"&gt;&lt;/div&gt; &lt;!-- ./webpack.config.js 中配置输出的 js 打包文件 --&gt; &lt;script src=\"bundle.js\"&gt;&lt;/script&gt;&lt;/body&gt; 修改入口文件 ./src/index.js，内容如下： 1234567import React from 'react'import ReactDOM from 'react-dom'ReactDOM.render( &lt;div&gt;Hello, React.&lt;/div&gt;, document.getElementById('root')) 4. Babel上面例子运行会报语法错误，应该 js 环境根本就不认识 &lt;div&gt;Hello, React.&lt;/div&gt;，所以我们需要引入 babel-preset-react 插件来将 jsx 语法转换成浏览器认识的 js，还有一点我们编写的是 es6 语法，所以也需要 babel-preset-es2015 等插件来转换，安装如下： 12yarn add -D babel-cli babel-core babel-preset-es2015yarn add -D babel-preset-react babel-plugin-transform-object-rest-spread 同时在根目录添加 ./.babelrc 文件，内容如下： 1234&#123; \"presets\": [\"es2015\", \"react\"], \"plugins\": [\"transform-object-rest-spread\"]&#125; 再次重启 Webapck，你就会在页面看到打印出来的 Hello, React. 了。 5. Antd Mobile ant desgin mobile 12345# 安装 antd-mobileyarn add antd-mobile# 安装按需加载依赖yarn add -D babel-loader babel-plugin-import 修改 ./.babelrc 文件： 12345678910111213&#123; \"presets\": [\"es2015\", \"react\"], \"plugins\": [ [ \"import\", &#123; \"libraryName\": \"antd-mobile\", \"style\": true &#125; ], \"transform-object-rest-spread\" ]&#125; 修改 ./src/index.js 文件： 12345678import React from 'react'import ReactDOM from 'react-dom'import &#123; Button &#125; from 'antd-mobile'ReactDOM.render( &lt;div&gt;&lt;Button type=\"primary\"&gt;Hello, React.&lt;/Button&gt;&lt;/div&gt;, document.getElementById('root')) 6. Style-loader但我们添加自己的 CSS 文件，像 js 那样引入时，就需要 style-loader、css-loader 加载器来协助完成。 12# 安装yarn add -D style-loader css-loader 往 ./webpack.config.js 文件加入 loader： 1234567891011121314151617181920212223const path = require('path')module.exports = &#123; // 程序入口文件 entry: './src/index.js', // 项目导入目录与文件 output: &#123; path: path.resolve(__dirname, 'dist'), filename: 'bundle.js' &#125;, module: &#123; rules: [ &#123; test: /\\.css$/, use: [&#123; loader: 'style-loader' &#125;, &#123; loader: 'css-loader' &#125;] &#125; ] &#125;&#125; 7. Mock Mock.js 官网 Webpack Wock 插件 现在前后端开发分离，已经成为业界一大主流。当一个项目需求下来，分工明确，但其中的协同合作就比较密切了，前端需要拿到后端的 API 接口才能进一步的开发，但后端的逻辑更为复杂，往往不可能第一时间给出响应的接口数据。这时候我们就要用到 Mock 了，需求一下来，前后端第一步就该协定“接口文档”（这个槽点在很多公司都存在），文档一定下来，我们就可以使用 Mock 模拟出与正式环境一模一样的数据了，开发毫无阻碍。 123# 安装依赖yarn add mockjsyarn add -D webpack-api-mocker 往 ./webpack.config.js 文件加入 mocker 插件：123456789101112131415161718192021222324252627282930const path = require('path')const apiMocker = require('webpack-api-mocker')module.exports = &#123; entry: './src/index.js', output: &#123; path: path.resolve(__dirname, 'dist'), // filename: '[chunkhash].js' filename: 'bundle.js' &#125;, module: &#123; rules: [ &#123; test: /\\.css$/, use: [&#123; loader: 'style-loader' &#125;, &#123; loader: 'css-loader' &#125;] &#125; ] &#125;, devServer: &#123; historyApiFallback: true, before(app) &#123; apiMocker(app, path.resolve('mocker/index.js'), &#123;&#125;) app.listen(8090) &#125; &#125;&#125; 添加 ./mocker/index.js 文件：12345678910111213141516171819202122232425262728const Mock = require('mockjs')const proxy = &#123; [`GET /api/list`]: (req, res) =&gt; &#123; return res.json(&#123; ...Mock.mock(&#123; 'status|0-1': 1, 'list|10': [ &#123; 'id|10-100': 34, title: '@ctitle(6, 20)', subtitle: '@date', 'extra|1': true &#125; ], page: &#123; 'p|+1': 1, 'count|192-491': 100 &#125;, message: function () &#123; return this.status ? 'get success...' : 'get failure...' &#125; &#125;) &#125;) &#125;&#125;module.exports = proxy 这时候你在浏览器中输入域名后面带上端口 8090，加上 /api/list 就可以看到接口数据，it&#39;s cool, man. 8. React router前后端分离后，前端页面不需要经过后端控制器跳转，前端想怎么跳就怎么跳。所以我们需要引入路由工具，那么 React 配套的就是 react-router 了，浏览器端需要引入 react-router-dom，它继承了 react-router 所有特性，并兼容了浏览器端各种特性。 12# 安装依赖yarn add react-router-dom 修改 ./src/main.js 文件，加入 2 个路由组件。123456789101112131415161718192021222324import React from 'react'import ReactDOM from 'react-dom'import &#123; BrowserRouter as Router, Route&#125; from 'react-router-dom'// 引入两个路由组件// views 开头路径在 wepack 那一篇文章里配置了 别名，指向 `./src/views`import home from 'views/home'import user from 'views/user'// 需要注意的是 path=\"/\" 时，添加了 exact 关键字// 表示严格匹配，后面的就是在匹配到也不再渲染ReactDOM.render( &lt;Router&gt; &lt;div&gt; &lt;Route exact path=\"/\" component=&#123;home&#125; /&gt; &lt;Route path=\"/user\" component=&#123;user&#125; /&gt; &lt;/div&gt; &lt;/Router&gt;, document.getElementById('root')) 配置完成，重启 webpack，访问根路径渲染 home 组件，访问 /user 路径则渲染 user 路径 9. sass-loader 世界上最成熟、最稳定、最强大的专业级 CSS 扩展语言！ 默哀 Compass sass 应该是 css 预处理器中最顶尖的选手了吧，入此师门是因为当年有 Compass。现在有各种 babel，它已经慢慢被人遗忘，默哀。 1234# 安装依赖# 也是需要 style-loader css-loader 支持# 很幸运，我们已经安装了它们yarn add -D sass-loader 在 ./webpack.config.js 中引入： 123456789101112// 如果单纯只有 sass 文件的话，可以删除上面的 css-loader 规则// 如果同时存在 css、sass 文件，则跟随 css-loader 后面加上：&#123; test: /\\.scss$/, use: [&#123; loader: 'style-loader' &#125;, &#123; loader: 'css-loader' &#125;, &#123; loader: 'sass-loader' &#125;]&#125; 10. eslint-loader esLint 中文 前端规范？每个人有自己的代码风格，这个在团队协作中很头疼，特别对处女座的同事们，连个 ; 都会抓狂。这时候引入前端火得不得了的 eslint，会让你的代码精美一致，谁看谁惊叹。 1234# 安装依赖yarn add -D eslint eslint-config-standard eslint-plugin-importyarn add -D eslint-loader eslint-plugin-node eslint-plugin-reactyarn add -D eslint-plugin-promise eslint-plugin-standard 在 ./webpack.config.js 中引入： 12345678910// 跟随 scss-loader 后面加上：&#123; test: /\\.js$/, exclude: /node_modules/, use: [&#123; loader: 'babel-loader' &#125;, &#123; loader: 'eslint-loader' &#125;]&#125; 11. ReduxRedux 是 React 的状态管理工具，比起 Vue 的 Vuex，Redux 复杂、诡异。但是 精于此道，以此为生！ 这位看官，请往这边走","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://blog.mrsuper.top/categories/JavaScript/"},{"name":"React","slug":"JavaScript/React","permalink":"http://blog.mrsuper.top/categories/JavaScript/React/"}],"tags":[{"name":"react","slug":"react","permalink":"http://blog.mrsuper.top/tags/react/"},{"name":"zero-based","slug":"zero-based","permalink":"http://blog.mrsuper.top/tags/zero-based/"}]},{"title":"Git 从入门到放弃","slug":"linux/toots/git","date":"2018-04-26T19:06:27.000Z","updated":"2018-09-03T08:39:08.062Z","comments":true,"path":"2018/04/27/linux/toots/git/","link":"","permalink":"http://blog.mrsuper.top/2018/04/27/linux/toots/git/","excerpt":"","text":"千万别让自己沉溺于安逸，“迷茫”？其实那都是借口。别扯什么选择大于努力，那都是运气在搞怪。人生还有很多美好等着遇见你，别辜负了时间，也别委屈了岁月。当然也可以选择自暴自弃，那也不枉为是一种人生态度！ Git 简史同生活中的许多伟大事物一样，Git 诞生于一个极富纷争大举创新的年代。Linux 内核开源项目有着为数众广的参与者。绝大多数的 Linux 内核维护工作都花在了提交补丁和保存归档的繁琐事务上（1991－2002年间）。到 2002 年，整个项目组开始启用一个专有的分布式版本控制系统 BitKeeper 来管理和维护代码。到了 2005 年，开发 BitKeeper 的商业公司同 Linux 内核开源社区的合作关系结束，他们收回了 Linux 内核社区免费使用 BitKeeper 的权力。这就迫使 Linux 开源社区（特别是 Linux 的缔造者 Linus Torvalds）基于使用 BitKeeper 时的经验教训，开发出自己的版本系统。他们对新的系统制订了若干目标： 速度 简单的设计 对非线性开发模式的强力支持（允许成千上万个并行开发的分支） 完全分布式 有能力高效管理类似 Linux 内核一样的超大规模项目（速度和数据量） 自诞生于 2005 年以来，Git 日臻成熟完善，在高度易用的同时，仍然保留着初期设定的目标。 它的速度飞快，极其适合管理大项目，有着令人难以置信的非线性分支管理系统。 相关资料 Git 官网 Pro Git 中文第一版（密码：7ipf） 相关教程 廖雪峰老师的干货 Git Book 中文 疑难杂症 windows 10 安装失败 黑科技12# 同时删除多个临时分支（包含“+”符号）git branch | grep '+' | xargs git branch -d 0. 初始化在 Git 官网下载后，Windows 安装 Git 就跟安装 QQ 一样简单，一直点击“下一步（next）”即可。Git 安装默认自动配置 Path 变量，所以无需再手动录入 Path。然而可能某些不可抗因素：Git 安装目录变更、系统重装、安全软件误删配置文件等等，那么就需要手动配置，其实也很简单。 如果你初次安装，而且勾选了自动配置 Path 变量，请忽略以下步骤： 打开“我的电脑”（win 10：打开“计算机”） 在空白处右键选择“属性” 弹出系统面板，在左边导航点击“高级系统配置” 弹出系统属性面板，切换到“高级”标签页 点击最下面的“环境变量”按钮 在下面的“系统变量”框里找到 Path 变量 修改值，再值最后面加上 Git 的安装目录，如：;D:\\Git\\ 千万记住不要修改其他的值，记得不要忘了在路径前面加上分号，与其他值隔开，大功告成 这个点很重要：安装完成之后，在安装目录下有个 git-bash.exe 文件，Windows 系统下完全可以使用该程序当成终端命令工具，Windows 自带的 cmd 程序根本没法跟她比，也没必要再去安装其它的终端工具。git-bash.exe 支持 Linux 命令、命令补全、颜色高亮、Git 分支状态提示、窗口还支持透明化，超有科技感。越用越爽，谁用谁知道。 1234567# 新建一个项目目录，或者在已有的项目的根目录里cd f:mkdir git-demo# 在 f:/git-demo 目录中# 初始化 Gitgit init 1. 本地配置12345678# 查看所有配置项git config --list# 查看已经配置过的全局变量git config --global --list# 查看某一项git config user.name 1.1 命令执行结果显示颜色高亮1git config --global color.ui true 1.2 添加忽略配置文件 .gitignore# 号开头表示注释/ 开头表示目录支持正则的通配符 *、?、^、$…下面贴出 Node.js 下环境常用配置： 1234567891011121314151617181920# 开发依赖目录/node_modules# 测试报告目录/coverage# 打包的目录，一般提交至其他仓库/build# 其他编辑器、插件的本地的配置文件.DS_Store.env.local.env.development.local.env.test.local.env.production.local# 错误日志npm-debug.log*yarn-debug.log*yarn-error.log* 1.3 命令别名建议不要配置别名，可读性太差了，易出错，而且更换开发环境之后还得重新再配置一次，繁琐而无益。 12345678git config --global alias.st statusgit config --global alias.co checkoutgit config --global alias.ci commitgit config --global alias.br branchgit config --global alias.re remote# 以后提交版本使用命令如下git ci -m \"...\" 1.4 用户信息提交版本信息时，Git 会提示你需要配置你的大名与邮箱地址，这时候你可以全局配置这些信息，除非你现在在网吧（） 123456# git config --global user.name [您最自豪的英文名]# git config --global user.email [邮箱地址]# 名字存在空格时，需要带上双引号（或单引号）git config --global user.name Supergit config --global user.email linzechao44@163.com 1.5 Git 命令行编辑器IT 小常识： Vim：编辑器之神（是 Git、Linux 默认的编辑器，Windows -&gt; Gvim） Emacs：神之编辑器（据说可以连接脚踏板设备一起编程，传说中的“手真的不够用”） 1git config --global core.editor emacs 2. 基本操作命令这一节主要介绍 Git 对文件的管理命令。如果你养成规范的保存习惯，代码随便改，丢了我赔（） 2.1 修改文件后12345678910# 查看文件状态git status# 修改文件后查看修改情况（增删会标记“+”绿色、“-”红色）# git diff [文件名]git diff README.md# 使用 difftool 工具对比# 根据上面《1.5 Git 命令行编辑器》所配置的编辑器打开git difftool README.md 2.2 放入暂存区12345678910# git add [文件名]git add README.md# *：表示所有文件# .：表示当前目录所有文件git add *git add .# 查看暂存区状态git status 2.3 对比暂存区1234# 对比暂存区（文件修改情况）# git diff [文件名] --cached# --cached 与 --staged 效果一样，只是当年 Git 作者也有强迫症才改名git diff README.md --staged 2.4 提交暂存区1234567891011121314151617181920212223242526272829# git commit -m [提交信息内容]# -m [提交信息内容]：必须项git commit -m \"[UPDATE] 修改自述文件\"# 再次修改 README.md 文件，需要重复命令git add README.mdgit commit -m \"[UPDATE] 修改自述文件\"# 这时可以带上 -a 参数git commit -a -m \"[UPDATE] 修改个别文件\"# 相当于git add .git commit -m \"[UPDATE] 修改个别文件\"# 注意：该组合只对已存在的文件修改有效，新增的文件，仍需 `git add .` 命令# 移除文件（删除）# git rm [文件名]git rm README.md# 相当于rm -rf README.mdgit add README.md# 移动文件# git mv [文件名] [新文件名]git mv README.md readme.md# 相当于mv README.md readme.mdgit rm README.mdgit add readme.md 2.5 查看提交日志1234567891011121314151617181920212223242526# 输出所有目录# 如果太多，按回车键往下看。# 默认 Vim 编辑器的话，可以 `Ctrl-f` 往下翻页看，`Ctrl-b` 往上翻页看，Cool...# 按 q 键退出git log# 打印最近的 2 条日志git log -2# 打印，并且显示修改内容git log -p# 打印，并且列出文件修改统计（哪些文件增加了多少，删除了多少）git log --stat# 选择格式打印git log --pretty=oneline# oneline：单行格式# format：自定义格式# %h：简短哈希字串版本号；# %s：提交说明；# %an：作者；# 最酷，最炫git log --pretty=format:\"%h %s %an\" --graph 2.6 撤销与回滚（小心了）123456789101112131415161718192021222324# 移除修改的内容（谨慎操作，不可逆）# git checkout -- [文件名]git checkout -- README.md# 或者使用 “.” 符号git checkout -- .# `git add README.md` 保存之后# 取消暂存的文件# git reset HEAD [文件名]git reset HEAD README.md# README.md 会回到之前修改过的状态，可以再次 `git add README.md` 添加回去# 假如 git commit -m \"打错字\"# 可以酱紫修改，原理是自动撤销再提交git commit --amend# 这时候会使用默认编辑器弹出一个编辑界面修改之前提交的信息即可# 当然这次操作也会被记录进版本控制# 暂存区全都提交了# git reset --hand [版本号]# 查看需要回滚的版本git log# 再回滚，不需要复制那么长，前面7，8位即可git reset --hand d91b7f5 2.7 stash 存储器要养成经常保存的好习惯，自然界中不可抗因素都会导致你的代码瞬间灰飞烟灭。还有每次切换分支时，你得保存你的代码，如果使用 git commit 每次都会保存一个没必要的版本号，影响以后查看提交日志。这时候就是 stash 派上用场，stash 是本地的，不会被 git commit，也不会被 git push，安心使用。 以前试过一次，把辛辛苦苦打了一天的文章给撤销回去了，吓得机智的我马上 Ctrl-z，醉啊哩哩…（），其实都是可以回滚的， 淡定！ 1234567891011121314151617# 把没 `git commit` 的更改数据存到一个 stash 中git stash# 遵循栈的数据结构，先进先出规则# 查看所有保存在 stash 的信息git stash list# 先开启 stash，再删除 stash# 默认都是指向最前面的那个存储器内容git stash applygit stash drop# 或者直接开启并且删除 stashgit stash pop# 指定开启 stashgit stash apply stash@&#123;0&#125; 3. 分支管理以上操作都是每个版本控制工具的基础，你有我也有，没啥好炫耀，然而 Git 比起其他工具（SVN 等…）最傲娇的就是分支特性了。这一章节掌握了，那么 Git 你也就学会了（是真的学会了），当你在分支直接穿梭自如的时候，别人看你操作就跟看魔术师表演一样，无上荣耀。来吧！骚年（） 3.1 创建、切换、删除123456789101112131415161718192021222324252627282930# Git 初始化默认处于 master 分支，而这个分支是非必要的# 用的人懒得改名，所以 master 已经成为标志性的主分支，即线上生产分支，一般人没权限操作# 查看当前分支（默认带上 -t 查看本地分支）# git branch -tgit branch# 前面带星号（*）、绿色名称的就是当前分支，一般初始化后只有一个 master 分支# 既然没有 master 操作权限，那就新建一个开发分支# git branch [分支名]git branch develop# 查看分支（git branch），可以看到多出一个 develop# 切换到开发分支# 小心喔，跟撤销修改的是同个关键字# 切换时记得把修改过的文件都提交版本（git commit）# 除非你那些修改的文件只想在 develop 分支提交，就可以直接切换git checkout develop# 查看分支（git branch），可以看到星号已经切换到 develop# 如果使用 `git-bash.exe` ，会提示当前处于哪个分支# 新建并切换分支，可以使用 -b 参数git checkout -b develop# 删除分支# 不能删除当前分支，所以删除前需要切换到其他分支# 再删除其他分支git branch -d develop# 如果要删除一个没有合并过的分支，可以使用强行删除git branch -D pay-action 3.2 合并、变基1234567891011121314151617181920212223242526272829# 有个紧急需求，需要开发一个支付功能，而且需要交付测试# 这时候就应该很自然的在当前分支保存所有代码，并提交到当前分支（issue-2018）# 1. 切换回 develop 开发分支git checkout develop# 2. 在开发分支新建一个新分支，并切换git checkout -b pay-action# 这时候你对着键盘一顿操作，搞定了需求# 并且把代码都提交到 pay-action 分支# 3. 切换回 develop 分支git checkout develop# 4. 合并分支的代码# git merge [分支名]git merge pay-action# Git 除了把 pay-action 提交的版本归纳到版本中# 还会帮你自动生成一个合并的版本并提交，一般是很丑的命名，# 而且没必要把合并的信息显示出来（自己合并自己的代码，别人不需要知道）# --------------------------------# 这时候就需要使用到 rebase 变基操作了# 回到步骤 3 之前，在 pay-action 分支中，操作以下命令git rebase develop# 再继续走上面的步骤3、4，这时候 Git 会当做你是在同一个分支上开发的代码# 生成一个类似“补丁”的修改文件提交# 以后看版本日志时就清爽多了 3.3 查看合并12345678910# 查看当前分支与其他分支合并情况# 已合并的分支git branch --merged# 未合并的分支git branch --no-merged# 查看分支合并情况git log --graph --pretty=oneline --abbrev-commit# 与下面命令的区别在于，上面有高亮，也包含合并情况git log --pretty=format:\"%h %s %an\" --graph 4. 标签操作标签与 git commit 之后一样是一个版本提交，只是标签用来标识项目某个节点，或者某个里程碑，信息更详细，也不会像提交版本那么频繁，而不好查阅。 4.1 新增、删除1234567891011121314151617181920# 切换到要添加标签的分支上，一般只为 master 分支打 taggit checkout master# 简单标签，简单粗暴，一般为节点git tag v1.2.1# 带信息的标签，一般为里程碑git tag -a v2.2.0 -m \"version 2.2.0 上线\"# 查看所有标签git tag# 给历史 `git commit` 的版本打标签git tag v1.2.4 e62f93# 查看某个标签信息git show v1.0# 删除标签git tag -d v1.2.q 5. 远程仓库我在本地提交那么多代码版本，只能在我的机子上看得到，别人就没办法了。这时候我们需要把本地版本提交到一个远程仓库，然后再公布给需要协作的人员，就可以一起玩耍了。而 GitHub 是全球同性交流网站（全球性免费的远程仓库)，我们可以把一些公开的源码放在上面。如果有一天马克·扎克伯格看到你的代码，并向你写了一封信，是不是想想就很激动？哈哈…（无耻的笑了） 5.1 Github在 Github 注册并验证邮箱完成之后，可以在个人主页里创建项目，而“拉取/提交”版本操作，有两种模式 https 协议：一般用于克隆或下载别人的仓库，如果用于自己仓库，则每次都需要输入账号密码，过于繁琐 SSH 安全协议 ：用于自己的远程库操作，安全，便捷 5.2 SSHssh-keygen 工具安装 Git 时已经自带安装，环境变量也已经配好，可以直接使用。 12345678910111213141516# 进入用户主目录# 使用 `git-bash` 的好处，简单粗暴使用 ~ 符号cd ~mkdir .sshcd .ssh# ssh-keygen -t rsa -C [你的远程库绑定的邮箱地址]ssh-keygen -t rsa -C \"linzechao44@163.com\"# 后面一系列操作都可以使用回车键来解决# 进入 .ssh 目录，至少可以看到 `id_res`、`id_rsa_pub`、`know_hosts` 这 3 个文件# id_res：密钥，打死也不能给别人知道# id_res_pub：公钥，打开里面文件，复制所有内容# 打开 GitHub 个人设置里的【SSH and GPG keys】# 新建一个，名称给你自己看，一般标识哪一台机器上的公钥# 把复制的公钥内容粘贴进文本域保存即可 5.3 克隆远程库123456789101112131415161718192021222324252627# 直接克隆远程库# git clone git@github.com:[你的 Github 账号名]/[你的项目名].gitgit clone git@github.com:linzechao/seo.git# 克隆的是 Github 上面默认的分支# 克隆一个远程库的一个分支# git clone -b [分支名] git@github.com:linzechao/seo.gitgit clone -b develop git@github.com:linzechao/seo.git# 克隆之后，会在当前目录产生一个以远程库名一样的文件夹（/seo）# 如需该文件夹名，则在后面带上命名即可# git clone git@github.com:linzechao/seo.git [文件夹名]git clone git@github.com:linzechao/seo.git origin-seo# 进入文件夹，查看远程有哪些分支# -v：带最后一次版本号的信息内容git branch -a# --------------------------------# 如果现在已经存在本地库，则使用添加远程库的操作即可# git remote add [远程库标识] git@github.com:linzechao/seo.git# 直接克隆下来的远程库标识默认就是 origin，也是行业内标志性的关键字，非硬性规定git remote add origin git@github.com:linzechao/seo.git# 修改远程库地址git remote set-url origin git@github.com:linzechao/origin-seo.git 5.4 拉取远程库版本123456789101112131415161718192021# 拉取（实际应用中很少用）git fetch origin master# 拉取下来还需要合并提交# 拉取并合并（代码冲突时会停在 `git fetch` 命令后，需要手动修改冲突再合并）git pull origin master# 提交到远程git push origin master# 提交标签到远程库git push origin v2.2.0# 提交远程库，并设置默认远程库，以后直接使用 `git push` 代替提交git push -u origin master# 查看远程库信息git remote show origin# 重命名远程库标识git remote rename origin coding# 删除远程库git remote rm coding 5.5 远程库分支1234567# 删除远程分支# 切换到本地对应的分支git push origin :branch-name# 删除远程分支或标签git push origin --delete codinggit push origin --delete v2.0.1","categories":[{"name":"Linux","slug":"Linux","permalink":"http://blog.mrsuper.top/categories/Linux/"},{"name":"Tools","slug":"Linux/Tools","permalink":"http://blog.mrsuper.top/categories/Linux/Tools/"}],"tags":[{"name":"tools","slug":"tools","permalink":"http://blog.mrsuper.top/tags/tools/"},{"name":"git","slug":"git","permalink":"http://blog.mrsuper.top/tags/git/"}]},{"title":"编辑器之神 Gvim","slug":"linux/toots/gvim","date":"2018-04-11T14:28:07.000Z","updated":"2018-08-03T02:05:36.713Z","comments":true,"path":"2018/04/11/linux/toots/gvim/","link":"","permalink":"http://blog.mrsuper.top/2018/04/11/linux/toots/gvim/","excerpt":"","text":"我的开发工具历程：从大学时期的 TXT 纯文本入门，到 eclipse、MyEclipse。毕业前的 Webstorm，毕业后的 phpStorm。再到最后的 Sublime Text 3，直到遇见了 Gvim，才算真正找到归属。她在 Linux 系统下是默认编辑器，版本管理工具 Git 也是默认调用的编辑器。她能让你离开鼠标，释放你的右手，快速打码，让你爽到无法呼吸！ 相关资料 下载 Gvim 最全，最详细的中文文档 Web 前端常用插件 Vim 配色 Vim 实用技巧 - Drew Neil（密码：591n） 模式 Normal Mode：普通模式，预览、查看 Visual Mode：可视模式，即选择文本模式 Insert Mode：插入模式，即输入文本模式，就跟传统编辑器一样 Select Mode：选择模式，使用鼠标选择文本 Command-Line/Ex Mode：命令模式、Ex 模式 配置 windows在 Gvim 安装目录下，修改 _vimrc 文件即可 linux在用户根目录（~），复制 /etc/vim/vimrc 到 ~/.vimrc 1. map 前缀 n：普通模式下生效 v：可视模式下生效 i：插入模式下生效 c：命令模式下生效 12\" 比如插入模式下使用 Ctrl-y-, 替换 Tab 键来做为代码补全快捷方式imap &lt;C-y&gt;, &lt;Tab&gt; 2. silent leader 映射123\" 将 ,t 当做打开文件预览器的快捷方式let mapleader=\",\"map &lt;silent&gt;&lt;leader&gt;t :NERDTreeToggle&lt;CR&gt; 3. 以下为我常用的配置文件 Windows 下配置 Linux 下配置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109\" 设置鼠标运行模式为 Windows 模式\" ctrl-A 全选、ctrl-c 复制、ctrl-v 粘贴source $VIMRUNTIME/vimrc_example.vimsource $VIMRUNTIME/mswin.vimbehave mswin\" Gvim 窗口最大化au GUIEnter * simalt ~xset guioptions-=m \" 隐藏菜单栏set guioptions-=T \" 隐藏工具栏set guioptions-=L \" 隐藏左侧滚动条set guioptions-=r \" 隐藏右侧滚动条set guioptions-=b \" 隐藏底部滚动条set guioptions-=0 \" 隐藏 tab 栏set encoding=utf-8 \" 编码set guifont=Consolas:h12 \" 字体、字号set nu \" 显示行号set cursorline \" 突出当前行set tabstop=2 \" 设置默认为 2 个空格set sts=2 \" 设置 softtabstop 为 2 个空格，使用 tab 缩进后，删除也是整个 tab 删掉set expandtab \" 使用空格代替 tab 键set shiftwidth=2 \" 设置自动缩进 2 个空格（回车缩进 2 个空格）set nobackup \" 不生成备份文件set noswapfile \" 不缓存 *.swp 文件set noundofile \" 不缓存 *.un~ 文件set foldenable \" 开始折叠set foldmethod=indent \" 设置语法折叠set foldcolumn=0 \" 设置折叠区域的宽度为 0setlocal foldlevel=1 \" 设置折叠层数为 1set foldlevelstart=99 \" 打开文件是默认不折叠代码\" 用空格键来开关折叠nnoremap &lt;space&gt; @=((foldclosed(line('.')) &lt; 0) ? 'zc' : 'zo')&lt;CR&gt; \" 窗口切换nmap &lt;C-h&gt; &lt;C-w&gt;&lt;C-h&gt;&lt;CR&gt;nmap &lt;C-j&gt; &lt;C-w&gt;&lt;C-j&gt;&lt;CR&gt;nmap &lt;C-k&gt; &lt;C-w&gt;&lt;C-k&gt;&lt;CR&gt;nmap &lt;C-l&gt; &lt;C-w&gt;&lt;C-l&gt;&lt;CR&gt;\" 禁用影响 Gvim 快捷方式的 Windows 快捷方式unmap &lt;C-v&gt;\" 文件预览器let mapleader=\",\"nmap &lt;silent&gt;&lt;leader&gt;t :NERDTreeToggle&lt;CR&gt;autocmd bufenter * if (winnr('$') == 1 &amp;&amp; exists('b:NERDTree') &amp;&amp; b:NERDTree.isTabTree()) | q | endif\" js 文档nmap &lt;silent&gt;&lt;leader&gt;d &lt;Plug&gt;(jsdoc)\" windows 配色（linux 自带主题）colorscheme colorsbox-stnight\" windows 透明度（linxu 自带透明）\" http://www.vim.org/scripts/script.php?script_id=687\" 将 dll 文件放至 gvim.eve 同目录即可au GUIEnter * call libcallnr(\"vimtweak.dll\", \"SetAlpha\", 184)\" ---------------- 插件 ----------------filetype offset rtp+=~/.vim/bundle/Vundle.vimcall vundle#begin() \" 配色（需要手动复制、启动配色） \" 复制到 Gvim 安装目录下的 /vimfiles/colors 目录下 \" 在上面引入 Plugin 'mkarmona/colorsbox' \" 文件菜单 Plugin 'scrooloose/nerdtree' \" 文件搜索 Plugin 'kien/ctrlp.vim' \" 标签补全 Plugin 'mattn/emmet-vim' \" 自动补全各种括号、单双引号 Plugin 'Raimondi/delimitMate' \" js 文档 Plugin 'heavenshell/vim-jsdoc' \" js 高亮 Plugin 'pangloss/vim-javascript' \" es6 高亮 Plugin 'isRuslan/vim-es6' \" markdown 高亮 Plugin 'tpope/vim-markdown' \" vue 高亮 Plugin 'posva/vim-vue' \" react 高亮 Plugin 'mxw/vim-jsx' \" CSS 高亮 Plugin 'gko/vim-coloresque' \" CSS3 高亮 Plugin 'hail2u/vim-css3-syntax'call vundle#end()filetype plugin indent on","categories":[{"name":"Linux","slug":"Linux","permalink":"http://blog.mrsuper.top/categories/Linux/"},{"name":"Tools","slug":"Linux/Tools","permalink":"http://blog.mrsuper.top/categories/Linux/Tools/"}],"tags":[{"name":"tools","slug":"tools","permalink":"http://blog.mrsuper.top/tags/tools/"},{"name":"gvim","slug":"gvim","permalink":"http://blog.mrsuper.top/tags/gvim/"}]},{"title":"HTTP 协议","slug":"other/http/protocol","date":"2018-03-25T11:00:45.000Z","updated":"2018-08-03T02:05:36.715Z","comments":true,"path":"2018/03/25/other/http/protocol/","link":"","permalink":"http://blog.mrsuper.top/2018/03/25/other/http/protocol/","excerpt":"","text":"这几天面试被完虐了，尤其是「 HTTP 协议 」有点过分了。因此读了《HTTP 权威指南》之后，把一些重点记录于此，用以警惕自己。逃避是解决不了问题的，勇敢去碰壁，去撞墙吧，骚年！哈~ 相关资料 菜鸟教程 MDN HTTP 文档 HTTP权威指南 - 图灵程序设计丛书（密码：6xcd） 请求方法安全方法：请求之后，不会产生任何副作用，即被请求的资源不会受任何影响 GET：安全方法，表示从服务器读取文档 POST：向服务器发送资源（发送数据，类似于创建） PUT：与 GET 相反，向服务器写入文档（存储数据，类似于修改） DELETE：请求删除资源 HEAD：安全方法，表示请求资源，但只返回与 GET 方法一样的头部信息。 不获取资源的情况下了解资源情况 通过查看响应中的状态码，查询资源是否存在 通过查看头部信息，测试资源是否被修改 OPTIONS：请求服务器支持的功能、支持的方法、或者某些特殊资源支持哪些方法（跨域时经常用到） TRACE：客户端发起一个请求，该请求可能通过防火墙、代理、网关或其他应用程序，而 TRACE 会诊断这个请求是否通过验证，诊断、验证 扩展方法 LOCK：允许用户“锁定”资源。比如，可以在编辑某个资源的时候将其锁定，以防别人同时对其进行修改 MKCOL：允许用户创建资源 COPY：便于在服务器上复制资源 MOVE：在服务器上移动资源 状态码 100~199 信息性状态码 200~299 成功状态码 300~399 重定向状态码 400~499 客户端错误状态码 500~599 服务器错误状态码","categories":[{"name":"Other","slug":"Other","permalink":"http://blog.mrsuper.top/categories/Other/"},{"name":"HTTP","slug":"Other/HTTP","permalink":"http://blog.mrsuper.top/categories/Other/HTTP/"}],"tags":[{"name":"interview","slug":"interview","permalink":"http://blog.mrsuper.top/tags/interview/"},{"name":"http","slug":"http","permalink":"http://blog.mrsuper.top/tags/http/"}]},{"title":"WEB 进军中级","slug":"other/project/middle","date":"2018-03-13T09:04:23.000Z","updated":"2018-09-06T09:16:13.842Z","comments":true,"path":"2018/03/13/other/project/middle/","link":"","permalink":"http://blog.mrsuper.top/2018/03/13/other/project/middle/","excerpt":"","text":"相信各位看官已经看过《WEB 入坑宝典》。而这里介绍了入门之后需要哪些知识点再去提升自己，从而提高平时工作效率，减少繁琐但又需要的构建步骤、发布与测试操作。下面给出的方案选择其中一种即可，其他可只做参考。 开发环境前端开发环境最主流的要属 Node.js，自带 NPM（Node.js 的包管理器：Node package manager），所有依赖存放在 GitHub，只需要一个命令就可以下载下来。根本就不用再去官网下载，再放进项目目录，依赖更新时又得重新去官网下载，再覆盖原有依赖，其中的版本兼不兼容，你还得细看官网文档。Oh my god！不用怕，现在这些都交给 NPM 去做吧。 Node.js 下载安装 NPM 下载太慢？，用国内镜像源（CNPM） 比 NPM 下载还快的 Yarn 自动化工具来自 Grunt 的一句话：对于需要反复重复的任务，例如压缩（minification）、编译、单元测试、linting 等，自动化工具可以减轻你的劳动，简化你的工作。 1. GruntGrunt 生态系统非常庞大，并且一直在增长。由于拥有数量庞大的插件可供选择，因此，你可以利用 Grunt 自动完成任何事，并且花费最少的代价。如果找不到你所需要的插件，那就自己动手创造一个 Grunt 插件，然后将其发布到 npm 上吧。 grunt 中文 english edition 2. Glup用自动化构建工具增强你的工作流程！ glup 中文 english edition 3. WebPack（推荐）本质上，Webpack 是一个现代 JavaScript 应用程序的静态模块打包器（module bundler）。当 Webpack 处理应用程序时，它会递归地构建一个依赖关系图（dependency graph），其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。 webpack 中文 english edition CSS 预处理器预处理器是在真正的编译开始之前由编译器调用的独立程序。预处理器可以删除注释、包含其他文件以及执行宏（宏 macro 是一段重复文字的简短描写）替代。 1. LessLess 是一门 CSS 预处理语言，它扩展了 CSS 语言，增加了变量、Mixin、函数等特性，使 CSS 更易维护和扩展。 less 中文 bootstrap 慕课 - less 即学即用 2. Sass（推荐）世界上最成熟、最稳定、最强大的专业级CSS扩展语言！ sass 中文 english edition 3. Compass（基于 Sass）Compass 是一个开源的 CSS 创作框架。（Compass is an open-source CSS Authoring Framework.） 只有英文版 不怕，有慕课 构建型框架一个命令就把所有依赖、项目目录结构、打包、测试等工作都帮你做好了。 1. VueVue（读音 /vjuː/，类似于 view）是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。 vue v2 vue router vuex 2. Angluar一套框架，多种平台。移动端 &amp; 桌面端 angluar v6 3. React用于构建用户界面的 JavaScript 库 react 中文 react-router-dom 中文 redux","categories":[{"name":"Other","slug":"Other","permalink":"http://blog.mrsuper.top/categories/Other/"}],"tags":[{"name":"tools","slug":"tools","permalink":"http://blog.mrsuper.top/tags/tools/"},{"name":"other","slug":"other","permalink":"http://blog.mrsuper.top/tags/other/"}]},{"title":"Docker 你值得拥有","slug":"linux/docker/index","date":"2018-03-09T19:06:27.000Z","updated":"2018-08-03T02:05:36.712Z","comments":true,"path":"2018/03/10/linux/docker/index/","link":"","permalink":"http://blog.mrsuper.top/2018/03/10/linux/docker/index/","excerpt":"","text":"以前搭建 JAVA 开发环境的时候，那叫一个痛苦啊，JDK、SQL Sever 2005、Tomcat 全部手动自己下载、安装、配置，错一步就要调试很久。后来接触 PHP，有了 wamp/wnmp，一键安装，一劳永逸。但是现在，我的老人机已经跟不上时代，配置有点尴尬，这时 Docker 出现了，Oh my god！老人机的第二春来了。这里展示的只是她冰山一角的魅力，以后你会越来越懂她的性感，哈哈！ 相关教程 阮一峰老师的干货 Docker 手册 菜鸟 Docker 相关资料 DockerHub，Docker 版的 GitHub Docker 中文 镜像加速 什么是 Docker？Docker 是一个开源的引擎，可以轻松的为任何应用创建一个轻量级的、可移植的、自给自足的容器。开发者在笔记本上编译测试通过的容器可以批量地在生产环境中部署，包括 VMs（虚拟机）、bare metal、OpenStack 集群和其他的基础应用平台。 Docker 通常用于如下场景： web 应用的自动化打包和发布 自动化测试和持续集成、发布 在服务型环境中部署和调整数据库或其他的后台应用 从头编译或者扩展现有的 OpenShift 或 Cloud Foundry 平台来搭建自己的 PaaS 环境 1. 镜像（image）二进制文件，一般继承自另一个镜像文件，再加上一些个性化而生成 12345678# 查看镜像列表docker images# 或docker image ls# 根据 Dockerfile 打包 image# -t 后面带上名称，版本号可选docker image build -t name[:tag] . 2. 容器（container）由镜像生成出来，可运行的程序文件抽象点，类似于面向对象：container = new image() 12345678910111213141516171819202122232425262728293031323334# 查看在运行的容器列表docker container ls# 或docker container list# 所有docker container ls --all# 终止docker container kill [containerID]# 删除docker container rm [containerID]# 运行docker container run -p 8000:3000 -it koa-demo /bin/bash# -p 端口映射# -it 容器 Shell 映射至当前的 Shell# --rm 慎用，容器运行结束后直接删除容器文件# -d 后台运行# /bin/bash 运行的第一个命令，启动 Bash，保证用户可以使用 Shell# 如果 Dockerfile 中包含了 CMD 命令，则上面参数不能再带，否则被覆盖，带了也无效# 缩写：-v# --volume \"$PWD/\":/var/www/html# 将当前目录（$PWD）映射到容器的 /var/www/html（Apache 对外访问的默认目录）。# 因此，当前目录的任何修改，都会反映到容器里面，进而被外部访问到。# 缩写：-e# --env MYSQL_ROOT_PASSWORD=123456# 向容器进程传入一个环境变量 MYSQL_ROOT_PASSWORD，该变量会被用作 MySQL 的根密码。# --env MYSQL_DATABASE=wordpress# 向容器进程传入一个环境变量 MYSQL_DATABASE# 容器里面的 MySQL 会根据该变量创建一个同名数据库（即 WordPress）。 3. Dockerfile 文件只有一个 CMD，但是可以多个 RUN 123456FROM node:8.4COPY . /appWORKDIR /appRUN npm install --registry=https://registry.npm.taobao.orgEXPOSE 3000CMD node demos/01.js FROM node:8.4：该 image 文件继承官方的 node image，冒号表示标签，这里标签是8.4，即8.4版本的 node。 COPY . /app：将当前目录下的所有文件（除了 .dockerignore 排除的路径），都拷贝进入 image 文件的 /app 目录。 WORKDIR /app：指定接下来的工作路径为 /app。 RUN npm install：在 /app 目录下，运行 npm install 命令安装依赖。注意，安装后所有的依赖，都将打包进入 image 文件。 EXPOSE 3000：将容器 3000 端口暴露出来， 允许外部连接这个端口。 CMD node demos/01.js：进入容器后执行这条命令 完整步骤1234567891011121314151617181920212223# 1.拉取远程库的镜像docker image pull hello-world # 2.由镜像生成一个容器并运行# run 每次都会新建一个一模一样的容器# 如已经存在，请使用 start 命令docker container run hello-worlddocker container start [containerID]# 3.如果基于第 2 步的容器是服务，则需要下面来终止容器运行# kill 太凶残# 请使用 stop 代替使用docker container kill [containerID]docker container stop [containerID]# 查看日志docker container logs [containerID]# 进入容器内部docker container exec -it [containerID] /bin/bash# 拷贝容器中的文件至本机docker container cp [containerID]:[/path/to/file] .","categories":[{"name":"Linux","slug":"Linux","permalink":"http://blog.mrsuper.top/categories/Linux/"},{"name":"Docker","slug":"Linux/Docker","permalink":"http://blog.mrsuper.top/categories/Linux/Docker/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://blog.mrsuper.top/tags/linux/"},{"name":"docker","slug":"docker","permalink":"http://blog.mrsuper.top/tags/docker/"}]},{"title":"广州火炉山“驾考”之旅","slug":"live/car/driving-test","date":"2018-02-22T20:39:26.000Z","updated":"2018-08-03T02:05:36.715Z","comments":true,"path":"2018/02/23/live/car/driving-test/","link":"","permalink":"http://blog.mrsuper.top/2018/02/23/live/car/driving-test/","excerpt":"","text":"1 年前，当时还没考驾照，就打算做一篇「 驾考 」的记录与心得体会，或许可以给大家加点经验值。人天性就是懒，拖了 1 年，然而刚好跟朋友聊起驾考的心酸，才突然想起这事，赶紧跑回来补上。人生就不一样了，错过了，就再也补不回来了。 时间穿梭，波诺波罗蜜~ 2017-02-11 询问警辉驾校（凌塘村训练场），我们 5 个人去，驾校有个女的跟我们介绍了一番，最后确定地说，最少就算团购价 ￥6500 2017-02-18 询问了住楼下的教练，他开价 ￥6280（其中 2 个人包了居住证办理） 他在楼梯口贴了“本楼与李教练合作，电话：13********，…”，猿粪啊 2017-02-19 去训练场（那边有工作室）签合同 搞笑的事情来了，那女的是李教练的二嫂子，哈哈哈哈 2017-02-19 签完合同带我们去拍照片（￥ 25） 2017-02-20 体检（￥ 15，周一至周六），把资料全交给教练，然后该上班的上班，该玩的玩，等通知 照片回执 居住证或居住证办理回执 身份证原件加正反面复印件 体检报告 2017-02-24 报名车管所受理（发短信通知） 这个时候，我开始看科目一题目了，好傻~ 2017-03-23 拿到 IC 卡（科目二、三练车时需要打卡加学时） 2017-03-24 预约理论课 周一预约下周一到周五 周五预约下周五、周六 预约网站 2017-04-02 上理论课 一天打 5 次卡（都是身份证加人脸识别） 上午 9 点上课[1]，下课 11 点 45 分[2] 中午 13 点上课，不用打卡 模拟课打卡 2 次[3、4] 下午下课 16 点 25 分打卡完成理论课[5] 2017-04-05 开始预约科目一 可以开始下载「 驾考宝典 」，看看科目一题目了 过了好久好久… 2017-06-03 科目一考试，不到 10 分钟交卷 98 分，答案太快了（我可是看了 3 个月的科目一题目啊，坑爹啊） 考完两三天后可以预约科目二 2017-06-24 科目二考试，不到 8 分钟考完 90 分，挂在半坡起步，“车头距离线超过 10cm，但不超过 30cm ” 2017-09-02 科目三考试，不到 15 分钟，100 分。第一次挂在起步，靠边停，空挡挂到了 4 档 2017-09-19 科目四（科目三理论），不到 8 分钟，100 分，nice… 我可是考完科目一之后就马上开始看科目四的，3 个多月啊 2017-09-25 拿证，周一至周五上班才能领，可选择邮寄","categories":[{"name":"Live","slug":"Live","permalink":"http://blog.mrsuper.top/categories/Live/"},{"name":"Car","slug":"Live/Car","permalink":"http://blog.mrsuper.top/categories/Live/Car/"}],"tags":[{"name":"live","slug":"live","permalink":"http://blog.mrsuper.top/tags/live/"},{"name":"driving car","slug":"driving-car","permalink":"http://blog.mrsuper.top/tags/driving-car/"}]},{"title":"WEB 入坑宝典","slug":"other/project/begin","date":"2018-02-14T20:24:53.000Z","updated":"2018-09-06T09:15:15.141Z","comments":true,"path":"2018/02/15/other/project/begin/","link":"","permalink":"http://blog.mrsuper.top/2018/02/15/other/project/begin/","excerpt":"","text":"生活起起落落，吃得起咽的下。有时候遭遇与巧合汇集一处，真的可以强大到将一个健壮骚年打击到落魄不堪。如果你身前没有任何后盾，那就让自己多穿点防弹衣吧。根据个人经验，帮大家整理了入门 Web 前端需要哪些技能技点。 1. HTML超文本标记语言（HyperText Markup Language，简称：HTML），是一种用于创建网页的标准标记语言，标准通用标记语言下的一个应用。“超文本”就是指页面内可以包含图片、链接，甚至音乐、程序等非文字元素。超文本标记语言的结构包括“头”部分（英语：Head）、和“主体”部分（英语：Body），其中“头”部提供关于网页的信息，“主体”部分提供网页的具体内容。——百度百科 菜鸟先飞 HTML HTML5 慕课网 HTML + CSS 基础课程 2. CSS层叠样式表（英文全称：Cascading Style Sheets）是一种用来表现 HTML（标准通用标记语言的一个应用）或 XML（标准通用标记语言的一个子集）等文件样式的计算机语言。CSS 不仅可以静态地修饰网页，还可以配合各种脚本语言动态地对网页各元素进行格式化。CSS 能够对网页中元素位置的排版进行像素级精确控制，支持几乎所有的字体字号样式，拥有对网页对象和模型样式编辑的能力。——百度百科 菜鸟先飞 CSS CSS3 3. JavaScriptJavaScript 一种直译式脚本语言，是一种动态类型、弱类型、基于原型的语言，内置支持类型。它的解释器被称为 JavaScript 引擎，为浏览器的一部分，广泛用于客户端的脚本语言，最早是在 HTML（标准通用标记语言下的一个应用）网页上使用，用来给 HTML 网页增加动态功能。—— 百度百科 菜鸟先飞 基本语法 内置对象 DOM BOM 慕课网 DOM探索之基础详解篇 JavaScript 入门篇 JavaScript 进阶篇 4. JS 库JS 库指的是基于 JavaScript 的语法和特性上封装的一组函数库或对象，主要用来处理各大浏览器厂商的兼容性，提高开发效率。JS 库太多了，有时间库（Moment.js）、图标图形（chart.js）、绘图（D3.js）、模块化（Sea.js）等等。而入门且上手快的唯独于 JQuery。 JQuery v3.2.1 API 文档 慕课网 jQuery 基础（一）— 样式篇 jQuery 基础（二）— DOM篇 jQuery 基础（三）— 事件篇 5. 混合框架混合框架，有的包含 HTML/CSS（Layui、Mini）样式框架，有的则包含了 HTML/CSS/JavaScript（Bootstrap、ElementUI、Ant-design）全家桶，但入门且上手快的唯独于 Boostrap。 Bootstrap v3 官网 菜鸟先飞 Bootstrap v3 慕课网 Boostrap 快速入门","categories":[{"name":"Other","slug":"Other","permalink":"http://blog.mrsuper.top/categories/Other/"}],"tags":[{"name":"zero-based","slug":"zero-based","permalink":"http://blog.mrsuper.top/tags/zero-based/"},{"name":"other","slug":"other","permalink":"http://blog.mrsuper.top/tags/other/"}]},{"title":"JavaScript 排序","slug":"js/syntax/js-sort","date":"2018-01-21T18:27:21.000Z","updated":"2018-08-03T02:05:36.710Z","comments":true,"path":"2018/01/22/js/syntax/js-sort/","link":"","permalink":"http://blog.mrsuper.top/2018/01/22/js/syntax/js-sort/","excerpt":"","text":"JavaScript 中数组（Array）的方法中，已经有内置的排序了，那为什么笔者要写这一出呢？因为面试中出现频率太高了。 冒泡排序思想：每一次对比相邻两个数据的大小，小的排在前面，如果前面的数据比后面的大就交换这两个数的位置特点：排序算法的基础，简单实用易于理解。缺点就是比较次数多，效率低 1234567891011121314let array = [92, 4, 11, 0, 6, 31, 441, 5, 52]let length = array.lengthfor(let front = 0; front &lt; length - 1; front++) &#123; for(let back = front + 1; back &lt; length; back++)&#123; // 如果前面的数据比后面的大就交换 if (array[front] &gt; array[back]) &#123; [array[front], array[back]] = [array[back], array[front]] &#125; &#125;&#125;console.log(array)// [0, 4, 5, 6, 11, 31, 52, 92, 441] 快速排序思想：先找到一个基准点（一般指数组的中部），然后数组以基准点分成两部分，依次与基准点数据比较，如果比它小放左边，反则放右边特点：快速，常用。缺点就是需要再声明两个数组，浪费内存空间资源 12345678910111213141516171819202122232425262728let array = [92, 4, 11, 0, 6, 31, 441, 5, 52]function quickSort (array) &#123; let length = array.length if (length &lt;= 1) &#123; return array &#125; // 取基准点 let middleIndex = Math.floor(length / 2) // 取基准点数值，并且将其移除 let middleValue = array.splice(middleIndex, 1) // 左右数组，分别存放比基准点小与大的数值 let left = [] let right = [] // length - 1为移除基准点数后的长度 for (let index = 0; index &lt; length - 1; index++) &#123; let item = array[index] item &lt; middleValue ? left.push(item) : right.push(item) &#125; return quickSort(left).concat(middleValue, quickSort(right))&#125;console.log(quickSort(array))// [0, 4, 5, 6, 11, 31, 52, 92, 441]","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://blog.mrsuper.top/categories/JavaScript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://blog.mrsuper.top/tags/javascript/"},{"name":"interview","slug":"interview","permalink":"http://blog.mrsuper.top/tags/interview/"}]},{"title":"在广州建众的那些日子","slug":"live/work/jiangzhong","date":"2018-01-17T20:50:05.000Z","updated":"2018-07-31T09:08:08.827Z","comments":true,"path":"2018/01/18/live/work/jiangzhong/","link":"","permalink":"http://blog.mrsuper.top/2018/01/18/live/work/jiangzhong/","excerpt":"","text":"记录那些年在「 广州建众 」上班的日子和加过的班，还有那些可爱的同事儿。点点滴滴，都是成长的汗迹。新人进，旧人跑，谁都逃不过这种定律，唯有独饮反思其奥秘。 2018-01-17：第一天入职，开发团队就开始 996，噩梦的开始。 2018-03-04：2018 年第一季度会议，荣获“互联网-新人奖”，没有奖杯，但是有￥500。 2018-07-03：2018 年中会议，荣获“互联网-优秀员工”，有奖杯，有荣誉证书，有￥1000。","categories":[{"name":"Live","slug":"Live","permalink":"http://blog.mrsuper.top/categories/Live/"},{"name":"Work","slug":"Live/Work","permalink":"http://blog.mrsuper.top/categories/Live/Work/"}],"tags":[{"name":"work","slug":"work","permalink":"http://blog.mrsuper.top/tags/work/"}]},{"title":"个人语录","slug":"live/casual/ana","date":"2018-01-14T20:20:46.000Z","updated":"2018-07-31T09:08:08.827Z","comments":true,"path":"2018/01/15/live/casual/ana/","link":"","permalink":"http://blog.mrsuper.top/2018/01/15/live/casual/ana/","excerpt":"","text":"生活需要激情，工作需要热情！随笔记一记，可能会发现其中的真谛。 慢慢地，我发现我已经在这个世界里，「 掉队了 」！ 人生还有很多美好等着遇见你，别辜负了时间，委屈了岁月。 千万别让自己沉溺于安逸，“迷茫”？那其实都是借口。 一步一脚印，一拜一菩提，珍贵的不是开始，而是「 坚持 」。 「 别扯什么选择大于努力，那都是运气在作怪。 」","categories":[{"name":"Live","slug":"Live","permalink":"http://blog.mrsuper.top/categories/Live/"},{"name":"Casual","slug":"Live/Casual","permalink":"http://blog.mrsuper.top/categories/Live/Casual/"}],"tags":[{"name":"live","slug":"live","permalink":"http://blog.mrsuper.top/tags/live/"},{"name":"casual","slug":"casual","permalink":"http://blog.mrsuper.top/tags/casual/"}]},{"title":"Webpack 模块化","slug":"js/module/webpack","date":"2017-12-30T18:42:28.000Z","updated":"2018-08-03T02:05:36.709Z","comments":true,"path":"2017/12/31/js/module/webpack/","link":"","permalink":"http://blog.mrsuper.top/2017/12/31/js/module/webpack/","excerpt":"","text":"本质上，Webpack 是一个现代 JavaScript 应用程序的静态模块打包器（module bundler）。当 Webpack 处理应用程序时，它会递归地构建一个依赖关系图（dependency graph），其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。继 Sea.js、Require.js 后的模块化替代方案。 相关资料 Webpack 中文 下载123456789101112# 新建项目目录mkdir webpack-democd webpack-demo# 初始化项目yarn init -y# 添加 webpack 到依赖项yarn add -D webpack webpack-cli# 或者使用 npmnpm install --save-dev webpack webpack-cli 开始配置文件在项目的根目录下新建 ./webpack.config.js 配置文件，内容如下：1234567891011const path = require('path')module.exports = &#123; // 程序入口文件 entry: './src/index.js', // 项目导入目录与文件 output: &#123; path: path.resolve(__dirname, 'dist'), filename: 'bundle.js' &#125;&#125; 模板引入添加根目录 ./index.html 文件，内容如下：1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=\"zh-CN\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;从零开始搭建 React 开发环境&lt;/title&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt; &lt;meta name=\"renderer\" content=\"webkit\"&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- ./webpack.config.js 中配置输出的 js 打包文件 --&gt; &lt;script src=\"bundle.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 入口文件添加 ./src/index.js 文件，内容如下：123/* ./src/index.js */window.alert('hello, webpack')console.log('你好，webpack') 执行命令修改 ./package.json 配置文件中的 scripts 字段（没有则加上）12345&#123; \"scripts\": &#123; \"start\": \"webpack --watch --mode development\" &#125;&#125; 测试OK，Webpack 已全部配置完，现在执行下面一条命令，打开 index.html 到浏览器，如果弹出 “hello, webpack” 的警告框，关闭弹窗后，控制台打印出 “你好，webpack”，那么恭喜你，配置成功！12# 启动 package.json 中的 scripts（start） 命令yarn start 热加载你可以修改 ./src/index.js 文件，然后刷新页面，Webpack 都会帮你重新再打包一份 bundle.js 文件，但是，每次修改后，都得重新刷新页面，这样一点都不酷，这时候就要派出 webpack-dev-server 了，安装如下1yarn add -D webpack-dev-server 修改 package.json 文件12345&#123; \"scripts\": &#123; \"start\": \"webpack-dev-server\" &#125;&#125; 退出退出之前运行的命令，可以使用 Ctrl-c，然后再启动。启动后，你再去修改 ./src/index.js 文件，每次修改保存后，浏览器都会自动刷新。如果再配上一台显示器，就能让你爽到无法呼吸。1yarn start","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://blog.mrsuper.top/categories/JavaScript/"},{"name":"Module","slug":"JavaScript/Module","permalink":"http://blog.mrsuper.top/categories/JavaScript/Module/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://blog.mrsuper.top/tags/javascript/"},{"name":"module","slug":"module","permalink":"http://blog.mrsuper.top/tags/module/"}]},{"title":"RequireJS 模块化","slug":"js/module/require","date":"2017-12-09T17:31:23.000Z","updated":"2018-08-03T02:05:36.708Z","comments":true,"path":"2017/12/10/js/module/require/","link":"","permalink":"http://blog.mrsuper.top/2017/12/10/js/module/require/","excerpt":"","text":"中文网：Require.js 是一个 JavaScript 模块加载器。它非常适合在浏览器中使用，但它也可以用在其他脚本环境, 就像 Rhino and Node。使用 Require.js 加载模块化脚本将提高代码的加载速度和质量。Require.js 是我在 Sea.js 落幕后的替代方案，然而短短不到 1 年时间，Webpack 崛起，很感慨！ 相关资料 官方网址：https://requirejs.org Require.js 是一个 js 脚本加载器，它遵循 AMD（Asynchronous Module Definition）规范，实现 js 脚本的异步加载，不阻塞页面的渲染和其后的脚本执行，并提供了在加载完成之后的执行相应回调函数的功能； Require.js 要求 js 脚本必须要实现模块化，即文件化；而 Require.js 的作用之一就是加载 js 模块，也就是 js 文件。 Require.js 可以管理 js 模块/文件之间的依赖；即不同的框架例如 JQuery，Angular 等采用了不同的语法，而使用这些语法的js文件在导入时必须排在 JQuery 或 Angular 之后才能顺利执行，Require.js 则能够解决排序依赖问题。 兼容性 # 浏览器 版本 1 IE 6+ 2 Firefox 2+ 3 Safari 3.2+ 4 Chrome 3+ 5 Opera 10+ 下载1. node 环境安装依赖12345# yarnyarn add requirejs# npmnpm install --save requirejs 2. 使用 cdn 直接引入1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=\"zh-CN\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;requirejs 模块化&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script src=\"//cdn.bootcss.com/require.js/2.3.5/require.js\"&gt;&lt;/script&gt; &lt;!-- 线上引入 mini 版本 &lt;script src=\"//cdn.bootcss.com/require.js/2.3.5/require.min.js\"&gt;&lt;/script&gt; --&gt;&lt;/body&gt;&lt;/html&gt; 主要用法假设，我们的目录结构如下，并把 require.js 放入项目中： www/ index.html js/ main.js require.js lib/ jquery.js helper/ plate.js pen.js 定义模块1. 键值对定义123456// plate.js 文件define(&#123; color: 'white', size: 14, weight: 'bold'&#125;) 2. 函数式定义12345678910111213// pen.js 文件define(() =&gt; &#123; const color = 'white' const fill = dom =&gt; &#123; dom.style.color = this.color &#125; return &#123; color, fill &#125;&#125;) 3. 存在依赖的函数式定义12345678910// pen.js 文件define(['./plate'], plate =&gt; &#123; const fill = dom =&gt; &#123; dom.style.color = plate.color &#125; return &#123; fill &#125;&#125;) 引入使用12345678910111213141516171819202122232425// 全局配置requirejs.config(&#123; // 基础路径 baseUrl: '/js', // 路径 paths: &#123; jquery: '/lib/jquery', bootstarp: '/lib/bootstart', plate: '/helper/plate', pen: '/helper/pen' &#125;, // 引入模块时，自动引入其他模块或 css 文件 shim: &#123; 'bootstarp': '~/node_modules/bootstarp@3.2.1' &#125;&#125;)// 引入 jquery 并把赋予 $ 变量，暴露出对象// 引入 pen.js 并把赋予 pen 变量，暴露出对象require(['jquery', 'pen'], ($, pen) =&gt; &#123; pen.full($('body'))&#125;)","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://blog.mrsuper.top/categories/JavaScript/"},{"name":"Module","slug":"JavaScript/Module","permalink":"http://blog.mrsuper.top/categories/JavaScript/Module/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://blog.mrsuper.top/tags/javascript/"},{"name":"module","slug":"module","permalink":"http://blog.mrsuper.top/tags/module/"}]},{"title":"SeaJS 模块化","slug":"js/module/sea","date":"2017-12-05T16:43:10.000Z","updated":"2018-09-03T08:39:08.060Z","comments":true,"path":"2017/12/06/js/module/sea/","link":"","permalink":"http://blog.mrsuper.top/2017/12/06/js/module/sea/","excerpt":"","text":"百度百科：SeaJS 是一个遵循 CMD 规范的 JS 模块加载框架，可以实现 JS 的模块化开发及加载机制。作者玉伯，前淘宝 UED，现支付宝前端工程师。记得我是刚毕业（2014）的时候使用 Sea.js 进行项目模块化，用了不到半年时间，换成了 Require.js，之后又过了不到 1 年的时间，转而使用 Webpack。可见前端开发技术更新速度之快，然而在今天，许多前端框架都有自己自带的脚手架工具，Webpack 处境也是越来越尴尬了。 相关资料 玉伯的博客（github issue） 似官非官 Sea.js 手册与文档 Sea.js 官网（玉伯说过放弃治疗了） W3C 使用手册 兼容性 # 浏览器 版本 1 IE 5.5+ 2 Firefox 2+ 3 Safari 3.2+ 4 Chrome 3+ 5 Opera 10+ 下载1. node 环境安装依赖12345# yarnyarn add seajs# npmnpm install --save seajs 2. 直接使用 cdn 引入12345678910&lt;!DOCTYPE html&gt;&lt;html lang=\"zh-CN\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;seajs 模块化&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script src=\"//cdn.bootcss.com/seajs/3.0.2/sea.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 模块定义definedefine(id?, dependencies?, factory) 12345678910111213141516171819202122232425262728293031// ./lib/utils.js// 一般只使用第三个参数：工厂函数define((require, exports, module) =&gt; &#123; // require：用来加载依赖，不如引入 jquery const $ = require('jquery') // exports 用来暴露当前上下文（自身变量、函数） exports.color = 'white' exports.background = 'blank' exports.fill = function () &#123; console.log(`color: $&#123;this.color&#125;, background-color: $&#123;this.background&#125;`) &#125; // module.exports === exports // 以此类推&#125;)/* -------- 赤果果的分割线 -------- */// 或者直接定义一个对象返回，常用于配置文件。如下：define(&#123; color: 'white', background: 'black', fill: function () &#123; console.log(`color: $&#123;this.color&#125;, background-color: $&#123;this.background&#125;`) &#125;&#125;)// 以上等价于define(() =&gt; &#123; return &#123; color: 'white', background: 'black', fill: function () &#123; console.log(`color: $&#123;this.color&#125;, background-color: $&#123;this.background&#125;`) &#125; &#125;&#125;) 配置config12345678910111213141516171819seajs.config(&#123; // 开启开发测试 debug: true, // 延时设置 timeout: 30 * 1000, // 设置目录别名 paths: &#123; cdn: 'https://cdn.bootcss.com/' &#125;, // 设置依赖别名 alias: &#123; jquery: 'cdn/jquery/3.3.1/jquery.min.js', bootstrap: 'cdn/bootstrap/3.3.7/js/bootstrap.min.js', utils: './lib/utils' &#125;&#125;) 使用use123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang=\"zh-CN\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;seajs 模块化&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script src=\"//cdn.bootcss.com/seajs/3.0.2/sea.js\"&gt;&lt;/script&gt; &lt;script&gt; seajs.use(['jquery', 'utils'], ($, utils) =&gt; &#123; $('body').css(&#123; color, utils.color, backgroundColor: utils.background &#125;) &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://blog.mrsuper.top/categories/JavaScript/"},{"name":"Module","slug":"JavaScript/Module","permalink":"http://blog.mrsuper.top/categories/JavaScript/Module/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://blog.mrsuper.top/tags/javascript/"},{"name":"module","slug":"module","permalink":"http://blog.mrsuper.top/tags/module/"}]},{"title":"语法 hello world","slug":"english/basic/syntax","date":"2017-11-27T21:38:21.000Z","updated":"2018-07-31T09:08:08.820Z","comments":true,"path":"2017/11/28/english/basic/syntax/","link":"","permalink":"http://blog.mrsuper.top/2017/11/28/english/basic/syntax/","excerpt":"","text":"英语语法是针对英语语言进行研究后，英语语法系统地总结归纳出来的一系列语言规则。英语语法的精髓在于掌握语言的使用。重头开始学英语，一切都是新的开始，或许只是三分钟热度，但总比躺尸强多了。 其他教程 哔哩哔哩 - 重头开始学英语","categories":[{"name":"English","slug":"English","permalink":"http://blog.mrsuper.top/categories/English/"}],"tags":[{"name":"english","slug":"english","permalink":"http://blog.mrsuper.top/tags/english/"}]},{"title":"最美排版语言 Markdown","slug":"linux/toots/markdown","date":"2017-11-17T18:48:12.000Z","updated":"2018-08-03T02:05:36.714Z","comments":true,"path":"2017/11/18/linux/toots/markdown/","link":"","permalink":"http://blog.mrsuper.top/2017/11/18/linux/toots/markdown/","excerpt":"","text":"百度百科：Markdown 是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。Markdown 具有一系列衍生版本，用于扩展 Markdown 的功能（如表格、脚注、内嵌 HTML 等等），这些功能原初的 Markdown 尚不具备，它们能让 Markdown 转换成更多的格式，例如 LaTeX，Docbook。Markdown 增强版中比较有名的有 Markdown Extra、MultiMarkdown、 Maruku 等。这些衍生版本要么基于工具，如 Pandoc；要么基于网站，如 GitHub 和 Wikipedia，在语法上基本兼容，但在一些语法和渲染效果上有改动。 参考 Cmd Markdown 编辑阅读器 Markdown 语法说明 支持 Font Awesome 图标 标题，与 &lt;h1&gt; &lt;h2&gt; ... &lt;h6&gt;一致 标题一标题二标题三标题四标题五标题六12345678910标题一========标题二--------# 标题一## 标题二### 标题三#### 标题四##### 标题五###### 标题六 区块引用 小情歌 苏打绿这是一首简单的小情歌唱着人们心肠的曲折我想我很快乐当有你的温热脚边的空气转了 这是一首简单的小情歌唱着我们心头的白鸽我想我很适合当一个歌颂者青春在风中飘着 你知道就算大雨让整座城市颠倒我会给你怀抱受不了看见你背影来到写下我度秒如年难挨的离骚就算整个世界被寂寞绑票我也不会奔跑逃不了最后谁也都苍老写下我时间和琴声交错的城堡 1234567891011121314151617&gt; ### 小情歌 &lt;sub&gt;苏打绿&lt;/sub&gt;&gt; 这是一首简单的小情歌 &gt; 唱着人们心肠的曲折&gt; 我想我很快乐当有你的温热&gt; 脚边的空气转了&gt; &gt; 这是一首简单的小情歌&gt; &gt; 唱着我们心头的白鸽&gt; &gt; 我想我很适合当一个歌颂者&gt; &gt; 青春在风中飘着&gt; &gt; &gt; 你知道就算大雨让整座城市颠倒&gt; &gt; &gt; 我会给你怀抱&gt; &gt; &gt; 受不了看见你背影来到&gt; &gt; &gt; 写下我度秒如年难挨的离骚&gt; &gt; &gt; 就算整个世界被寂寞绑票&gt; &gt; &gt; 我也不会奔跑&gt; &gt; &gt; 逃不了最后谁也都苍老&gt; &gt; &gt; 写下我时间和琴声交错的城堡 列表 星号列表 星号列表 减号也行 减号也行 加号也罢 加号也罢 有序列表 需要加上序号 麻烦 维护差 Lorem ipsum dolor sit amet, consectetuer adipiscing elit.Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi,viverra nec, fringilla in, laoreet vitae, risus. Donec sit amet nisl. Aliquam semper ipsum sit amet velit.Suspendisse id sem consectetuer libero luctus adipiscing. 12345678910111213141516171819* 星号列表* 星号列表- 减号也行- 减号也行+ 加号也罢+ 加号也罢1. 有序列表2. 需要加上序号3. 麻烦4. 维护差* Lorem ipsum dolor sit amet, consectetuer adipiscing elit.Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi,viverra nec, fringilla in, laoreet vitae, risus.* Donec sit amet nisl. Aliquam semper ipsum sit amet velit.Suspendisse id sem consectetuer libero luctus adipiscing. 代码区块public class Brush { public static void main (String args[]) { system.out.print(&quot;Hello World!&quot;); } } 123456使用缩进 tab 键 public class Brush &#123; public static void main (String args[]) &#123; system.out.print(\"Hello World!\"); &#125; &#125; 分割符 1234567891011--------- - - -* * * *******--------分隔符，上下空一行，多于 3 个以上的 “-”，如不空行，则会被编译成 &lt;h2&gt;，如上，如下。-------- 区段元素这是一条去百度的超级链接Google link is http://google.com http://blog.mrsuper.top 1234567[这是一条去百度的超级链接](http://baidu.com \"百度一下\")[Google][1] link is `http://google.com`[1]: http://google.com \"Google one time\"&lt;http://blog.mrsuper.top&gt; 强调一颗星 斜体一条下划线 斜体 两颗星 加粗二条下划线 加粗 12345*一颗星 斜体*_一条下划线 斜体_**两颗星 加粗**__二条下划线 加粗__ 行内代码&lt;em&gt;&lt;/em&gt;&lt;strong&gt;&lt;/strong&gt; 里面包含反引号 ` ，需要 2 个反引号括起来 12345public class Brush &#123; public static void main (String args[]) &#123; system.out.print(\"Hello World!\"); &#125;&#125; 123456789101112`&lt;em&gt;&lt;/em&gt;``&lt;strong&gt;&lt;/strong&gt;``` 里面包含反引号 ` ，需要 2 个反引号括起来 ````` javapublic class Brush &#123; public static void main (String args[]) &#123; system.out.print(\"Hello World!\"); &#125;&#125;`` ` 图片 12345![这是一张 Markdown 的图片](http://asset.mrsuper.top/blog/concept/thumb/markdown.jpg \"点击查看大图\")![这是一张我大侄女的萌照][zhixin][zhixin]: http://asset.mrsuper.top/www/qzx/2.jpg \"点击查看萌照\" ICON 图标Font Awesome 图标 都支持，使用 class 属性，值以 fa fa- 为前缀。 1234- &lt;i class=\"fa fa-flag-checkered\"&gt;&lt;/i&gt;- &lt;i class=\"fa fa-gg\"&gt;&lt;/i&gt;- &lt;i class=\"fa fa-quote-left\"&gt;&lt;/i&gt;- &lt;i class=\"fa fa-smile-o\"&gt;&lt;/i&gt; 表格 # 左对齐 居中对齐 右对齐 1 IE Chao 4444 2 Firox Super 22 3 Safi Subo 8 4 Chre Lin 0631 123456| # | 左对齐 | 居中局 | 右对齐 || -- | :----- | :------: | -----: || 1 | IE | Chao | 4444 || 2 | Firox | Super | 22 || 3 | Safi | Subo | 8 || 4 | Chre | Lin | 0631 | 复选框 支持以 PDF 格式导出文稿 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率 新增 Todo 列表功能 修复 LaTex 公式渲染问题 新增 LaTex 公式编号功能 12345- [ ] 支持以 PDF 格式导出文稿- [ ] 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率- [x] 新增 Todo 列表功能- [x] 修复 LaTex 公式渲染问题- [x] 新增 LaTex 公式编号功能 公式很遗憾，Hexo 的 markdown 不支持公式、流程图等高级特效。有些工具、MD 编辑器是支持的。比如：Cmd Markdown 编辑阅读器！ $$ E=mc^2 $$$\\sum_{i=1}^n a_i=0$ 12345678st=&gt;start: Startop=&gt;operation: Your Operationcond=&gt;condition: Yes or No?e=&gt;endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op 123Alice-&gt;Bob: Hello Bob, how are you?Note right of Bob: Bob thinksBob--&gt;Alice: I am good thanks! 12345678910111213title 项目开发流程section 项目确定 需求分析 :a1, 2016-06-22, 3d 可行性报告 :after a1, 5d 概念验证 : 5dsection 项目实施 概要设计 :2016-07-05 , 5d 详细设计 :2016-07-08, 10d 编码 :2016-07-15, 10d 测试 :2016-07-22, 5dsection 发布验收 发布: 2d 验收: 3d","categories":[{"name":"Linux","slug":"Linux","permalink":"http://blog.mrsuper.top/categories/Linux/"},{"name":"Tools","slug":"Linux/Tools","permalink":"http://blog.mrsuper.top/categories/Linux/Tools/"}],"tags":[{"name":"tools","slug":"tools","permalink":"http://blog.mrsuper.top/tags/tools/"},{"name":"markdown","slug":"markdown","permalink":"http://blog.mrsuper.top/tags/markdown/"}]},{"title":"发音 ABC","slug":"english/basic/symbol","date":"2017-11-13T23:18:17.000Z","updated":"2018-09-03T08:39:08.059Z","comments":true,"path":"2017/11/14/english/basic/symbol/","link":"","permalink":"http://blog.mrsuper.top/2017/11/14/english/basic/symbol/","excerpt":"","text":"英语也是与电脑联系最密切的语言，大多数编程语言都与英语有联系，而且随着网络的使用，英文的使用更普及。英语是联合国的工作语言之一。 苏格兰语、低地撒克逊语、丹麦语、德语、荷兰语、南非荷兰语和英语也很接近。拥有法国血统的诺曼人于 11 世纪征服英格兰王国，带来数万法语词汇和拉丁语词汇，很大程度地丰富了英语词汇外，相对也驱使不少原生的语汇作废。 相关资料 在线发音 1. 短元音 [v] [v:] [e] 2. 长元音 [i:] [o:] [a:] [u:] [e:] 3. 双元音 [ai] [au] [ei] [ea] [ie] [ue] [oi] [eu] [oe] 4. 音标4.1 掐头法 音标： Ff Ll Mm Nn Ss Xx 读音： /f/ /l/ /m/ /n/ /s/ /ks/ 4.2 去尾法 音标： Bb Cc Dd Jj Kk Pp Tt Vv Zz 读音： /b/ /s/ /d/ /d3/ /k/ /p/ /t/ /v/ /z/ 4.3 对比法（中文拼音读音） 音标： Gg Hh Yy Ww Rr 读音： /g/ /h/ /j/ /w/ /r/","categories":[{"name":"English","slug":"English","permalink":"http://blog.mrsuper.top/categories/English/"}],"tags":[{"name":"english","slug":"english","permalink":"http://blog.mrsuper.top/tags/english/"}]}]}